<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Microsoft.ProgramSynthesis.Transformation.Formula</name>
    </assembly>
    <members>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Constraints.ConditionalLearnConstraint">
            <summary>
                Learning options.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Constraints.CSharpLearnConstraint">
            <summary>
                C# learning options.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Constraints.CSharpTranslationConstraint">
            <summary>
                CSharp translation options.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Transformation.Formula.Constraints.CSharpTranslationConstraint.MethodName">
            <summary>
                Sets the formula function name used during translation.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Transformation.Formula.Constraints.CSharpTranslationConstraint.Optimizations">
            <summary>
                Controls which optimizations are applied after translation.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Constraints.CSharpTranslationConstraint.ToEqualString">
            <inheritdoc />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Constraints.ExcelImplicitLearnConstraint">
            <summary>
                Excel learning options for Implicit scenarios.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Constraints.ExcelLearnConstraint">
            <summary>
                Excel learning options.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Transformation.Formula.Constraints.ExcelLearnConstraint.EnableForwardFill">
            <summary>
                Enable learning of Forward Fill operators.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Transformation.Formula.Constraints.ExcelLearnConstraint.EnableNumberSourceFirstPriority">
            <summary>
            Enable prioritization of number source values over all other number operations such as arithmetic.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Transformation.Formula.Constraints.ExcelLearnConstraint.EnableFromNumberCoalesced">
            <summary>
                Enables automatically coalesce to Zero for null and empty string values. Default Excel behavior.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Transformation.Formula.Constraints.ExcelLearnConstraint.EnableTrimFull">
            <summary>
                Enable learning of TrimFull operator.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Transformation.Formula.Constraints.ExcelLearnConstraint.ForwardFillMaxExampleCount">
            <summary>
                Maximum number of examples to consider when learning a forward fill program.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Transformation.Formula.Constraints.ExcelLearnConstraint.ForwardFillMaxScale">
            <summary>
                Maximum decimal places allowed in forward fill gradient &amp; intercept constants
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Transformation.Formula.Constraints.ExcelLearnConstraint.ForwardFillMinExampleCount">
            <summary>
                Minimum example count to learn a forward fill program
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Constraints.ExcelTranslationConstraint">
            <summary>
                Excel translation options.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Transformation.Formula.Constraints.ExcelTranslationConstraint.EnableFindN">
            <summary>
                Enable translation to the FindN function.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Transformation.Formula.Constraints.ExcelTranslationConstraint.EnableTextAfter">
            <summary>
                Enable translation to the TextAfter function.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Transformation.Formula.Constraints.ExcelTranslationConstraint.EnableTextBefore">
            <summary>
                Enable translation to the TextBefore function.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Transformation.Formula.Constraints.ExcelTranslationConstraint.EnableTextSlice">
            <summary>
                Enable translation to the TextSlice function.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Transformation.Formula.Constraints.ExcelTranslationConstraint.Optimizations">
            <summary>
                Controls which optimizations are applied after translation.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Transformation.Formula.Constraints.ExcelTranslationConstraint.ReferenceRowExpression">
            <summary>
                Sets the starting row number expression. Used when computing a relative row number in formulas.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Transformation.Formula.Constraints.ExcelTranslationConstraint.UserInterfaceCulture">
            <summary>
                Sets the default user culture. For operators that have a culture parameter, the learned culture will be omitted if
                it matches the default culture. Set to null if you do not want to omit a culture.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Constraints.FormulaConstraint.ConflictsWith(Microsoft.ProgramSynthesis.Wrangling.Constraints.Constraint{Microsoft.ProgramSynthesis.Wrangling.IRow,System.Object})">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Constraints.FormulaConstraint.Valid(Microsoft.ProgramSynthesis.Program{Microsoft.ProgramSynthesis.Wrangling.IRow,System.Object})">
            <inheritdoc />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Constraints.LearnConstraint">
            <summary>
                Learning options.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Transformation.Formula.Constraints.LearnConstraint.ColumnNamePriority">
            <summary>
                Specify the priority for column names. Learning prioritizes column names that appear earlier in the list.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Transformation.Formula.Constraints.LearnConstraint.ConditionalBranchMinExampleCount">
            <summary>
                Minimum example count required to establish a conditional cluster. Each true and false branch of a conditional
                statement must have at least ConditionalClusterMinExampleCount example.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Transformation.Formula.Constraints.LearnConstraint.ConditionalMaxBranches">
            <summary>
                Maximum number of conditional clusters to be learned. Limits the number of conditional branches in a program.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Transformation.Formula.Constraints.LearnConstraint.DataCultures">
            <summary>
                Specify cultures used to format dates and numbers. Learning prioritizes cultures that appear earlier in the list.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Transformation.Formula.Constraints.LearnConstraint.FromNumbersColumnLimit">
            <summary>
                Limit on the size of the sets of columns considered for aggregation operators such as sum, product and average.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Transformation.Formula.Constraints.OperatorLearnConstraint.ArithmeticConstantMaxInferredScale">
            <summary>
                Sets the maximum number of digits to the right of decimal point inferred for Multiply and Divide constants.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Transformation.Formula.Constraints.OperatorLearnConstraint.ArithmeticMinExampleCount">
            <summary>
                Minimum example count required to learn arithmetic operations
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Transformation.Formula.Constraints.OperatorLearnConstraint.EnableArithmetic">
            <summary>
                Enable learning of the arithmetic operations.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Transformation.Formula.Constraints.OperatorLearnConstraint.EnableArithmeticLeftConstant">
            <summary>
                Enable learning of constants as arithmetic arguments on the operator left side.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Transformation.Formula.Constraints.OperatorLearnConstraint.EnableArithmeticRightConstant">
            <summary>
                Enable learning of constants as arithmetic arguments on the operator right side.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Transformation.Formula.Constraints.OperatorLearnConstraint.EnableDateTimePart">
            <summary>
                Enable learning of the DateTimePart operator.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Transformation.Formula.Constraints.OperatorLearnConstraint.EnableDefaultColumnNamePriority">
            <summary>
                Enable column priority inferences based on examples and additional inputs. When active, columns containing blank or
                null values are given the lowest possible priority. DefaultColumnPriority is applied even when a ColumnNamePriority
                list is specified.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Transformation.Formula.Constraints.OperatorLearnConstraint.EnableFromDateTimePart">
            <summary>
                Enable learning of the FromDateTimePart operator.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Transformation.Formula.Constraints.OperatorLearnConstraint.EnableFromNumberStr">
            <summary>
                Enable learning of the FromNumberStr operator.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Transformation.Formula.Constraints.OperatorLearnConstraint.EnableLearningShortCircuit">
            <summary>
                Enable learning short circuit tactic.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Transformation.Formula.Constraints.OperatorLearnConstraint.EnableLength">
            <summary>
                Enable learning for the Length operator.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Transformation.Formula.Constraints.OperatorLearnConstraint.EnableMatch">
            <summary>
                Enable learning of Regular Expressions
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Transformation.Formula.Constraints.OperatorLearnConstraint.EnableMatchNames">
            <summary>
                Enable learning of Regular Expressions types.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Transformation.Formula.Constraints.OperatorLearnConstraint.EnableMatchUnicode">
            <summary>
                Allow use of Unicode character categories such as \o{Ll} in regular expressions.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Transformation.Formula.Constraints.OperatorLearnConstraint.EnableNegativePosition">
            <summary>
                Enable learning of negative positions using in Slice(), Split(), and Abs()
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Transformation.Formula.Constraints.OperatorLearnConstraint.EnableParseDateTimePartial">
            <summary>
                Enable learning of the ParseDateTime for partial date/time inputs.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Transformation.Formula.Constraints.OperatorLearnConstraint.EnableProperCase">
            <summary>
                Enable learning of the ProperCase operators
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Transformation.Formula.Constraints.OperatorLearnConstraint.EnableReplace">
            <summary>
                Enable learning for the Replace operator.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Transformation.Formula.Constraints.OperatorLearnConstraint.EnableRoundDateTime">
            <summary>
                Enable learning of the RoundDateTime operator.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Transformation.Formula.Constraints.OperatorLearnConstraint.EnableRoundNumber">
            <summary>
                Enable learning of the RoundNumber operator.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Transformation.Formula.Constraints.OperatorLearnConstraint.EnableSliceBetween">
            <summary>
                Enable learning of the SliceBetween operator.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Transformation.Formula.Constraints.OperatorLearnConstraint.EnableSplit">
            <summary>
                Enable learning of the Split operator.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Transformation.Formula.Constraints.OperatorLearnConstraint.EnableTimePart">
            <summary>
                Enable learning of the TimePart operator.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Transformation.Formula.Constraints.OperatorLearnConstraint.EnableTrim">
            <summary>
                Enable learning of the FromDateTimePart operator.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Transformation.Formula.Constraints.OperatorLearnConstraint.NumberFormatMaxLeadingDigits">
            <summary>
                Maximum leading digits used in number formatting.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Transformation.Formula.Constraints.OperatorLearnConstraint.NumberRoundMinExampleCount">
            <summary>
                Minimum example count required to round a number.
                Can be used to require a stronger signal that rounding is the true intent
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Constraints.OperatorLearnConstraint.ToEqualString">
            <inheritdoc />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Constraints.PandasLearnConstraint">
            <summary>
                Python learning options.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Constraints.PandasTranslationConstraint">
            <summary>
                Pandas translation options.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Transformation.Formula.Constraints.PandasTranslationConstraint.DataFrameName">
            <summary>
                Sets the variable name of the Pandas DataFrame.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Transformation.Formula.Constraints.PandasTranslationConstraint.DerivedColumnIndex">
            <summary>
                Sets the index in the data-frame to insert the derived column.
                If not specified, the new column will be inserted as the last column in the data-frame.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Transformation.Formula.Constraints.PandasTranslationConstraint.DerivedColumnName">
            <summary>
                Sets the name of the derived column name.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Transformation.Formula.Constraints.PandasTranslationConstraint.ImportPandas">
            <summary>
                Sets whether the pandas import statement should be included.
                The default is false.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Transformation.Formula.Constraints.PandasTranslationConstraint.PandasOptimizations">
            <summary>
                Controls which optimizations are applied after translation.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Transformation.Formula.Constraints.PandasTranslationConstraint.RegexLibrary">
            <summary>
                Sets the regular expression library to use during translation. Defaults to <see cref="!:regex" />.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Transformation.Formula.Constraints.PandasTranslationConstraint.TransformationFunctionName">
            <summary>
                Sets the name of the transformation function. Defaults to <see cref="P:Microsoft.ProgramSynthesis.Transformation.Formula.Constraints.PandasTranslationConstraint.DerivedColumnName" />.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Constraints.PandasTranslationConstraint.ToEqualString">
            <inheritdoc />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Constraints.PowerQueryLearnConstraint">
            <summary>
                PowerQuery learning options.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Constraints.PowerQueryTranslationConstraint">
            <summary>
                PowerQuery translation options.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Transformation.Formula.Constraints.PowerQueryTranslationConstraint.Optimizations">
            <summary>
                Controls which optimizations are applied after translation.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Transformation.Formula.Constraints.PowerQueryTranslationConstraint.UserInterfaceCulture">
            <summary>
                Sets the default user culture. For operators that have a culture parameter, the learned culture will be omitted if
                it matches the default culture. Set to null if you do not want to omit a culture.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Transformation.Formula.Constraints.PowerQueryTranslationConstraint.OutputType">
            <summary>
                Sets the output type of the translation. By default, the translation returns a lambda expression
                that performs the transformation.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Constraints.PySparkLearnConstraint">
            <summary>
                PySpark learning options.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Constraints.PySparkTranslationConstraint">
            <summary>
                PySpark translation options.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Transformation.Formula.Constraints.PySparkTranslationConstraint.ImportPySpark">
            <summary>
                Sets whether the PySpark import statement should be included.
                The default is false.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Transformation.Formula.Constraints.PySparkTranslationConstraint.PySparkOptimizations">
            <summary>
                Controls which optimizations are applied after translation.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Transformation.Formula.Constraints.PySparkTranslationConstraint.UseSqlDataFrame">
            <summary>
                There are two dataframes in PySpark: Sql (common) and Pandas-for-spark (uncommon).
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Constraints.PySparkTranslationConstraint.ToEqualString">
            <inheritdoc />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Constraints.PythonLearnConstraint">
            <summary>
                Python learning options.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Constraints.PythonTranslationConstraint">
            <summary>
                Python translation options.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Transformation.Formula.Constraints.PythonTranslationConstraint.DefinitionName">
            <summary>
                Sets the formula function name used during translation.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Transformation.Formula.Constraints.PythonTranslationConstraint.IndentLevel">
            <summary>
                Sets the indent level of the resulting code string; default is 0.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Transformation.Formula.Constraints.PythonTranslationConstraint.IndentSize">
            <summary>
                Sets the indent size of the resulting code string; default is 4.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Transformation.Formula.Constraints.PythonTranslationConstraint.MaximumExamplesInComments">
            <summary>
                Sets the maximum number of examples to include in the comments of the generated code.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Transformation.Formula.Constraints.PythonTranslationConstraint.LocalizedStrings">
            <summary>
                Sets the localized strings used in the translated code snippet.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Transformation.Formula.Constraints.PythonTranslationConstraint.UseNumpy">
            <summary>
                Sets whether to use the numpy library in the translation.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Transformation.Formula.Constraints.PythonTranslationConstraint.PythonOptimizations">
            <summary>
                Controls which optimizations are applied after translation.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Constraints.PythonTranslationConstraint.ToEqualString">
            <inheritdoc />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Constraints.SqlLearnConstraint">
            <summary>
                SQL learning options.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Constraints.SqlTranslationConstraint">
            <summary>
                SQL translation options.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Transformation.Formula.Constraints.SqlTranslationConstraint.Optimizations">
            <summary>
                Controls which optimizations are applied after translation.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Constraints.TranslationConstraint">
            <summary>
                Translation options.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Transformation.Formula.Constraints.TranslationConstraint.ExplanationTemplateProvider">
            <summary>
                Provides explanation templates. To implement custom templates, implement
                <see cref="T:Microsoft.ProgramSynthesis.Transformation.Formula.Explanations.IExplanationTemplateProvider" />. See <see cref="T:Microsoft.ProgramSynthesis.Transformation.Formula.Explanations.Default.DefaultExplanationTemplateProvider" /> as a reference
                implementation.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Transformation.Formula.Constraints.TranslationConstraint.SuppressConstantOutput">
            <summary>
                Suppress formulas that produce constant output.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Transformation.Formula.Constraints.TranslationConstraint.SuppressInconsistentOutput">
            <summary>
                Suppress formulas that produce blank or null output values for additional inputs.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Transformation.Formula.Constraints.TranslationConstraint.SuppressLowAcceptance">
            <summary>
                Formula acceptance prediction behavior.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Transformation.Formula.Constraints.TranslationConstraint.SuppressLowPrecision">
            <summary>
                Formula precision prediction behavior.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Transformation.Formula.Constraints.TranslationConstraint.SuppressWholeColumnOutput">
            <summary>
                Suppress formulas that produce output exactly the same as an input column.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Transformation.Formula.Explanations.Default.EmptyExplanationMeta.Key">
            <inheritdoc />
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Transformation.Formula.Explanations.Default.EmptyExplanationMeta.Replacements">
            <inheritdoc />
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Transformation.Formula.Explanations.Default.EmptyExplanationMeta.Text">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.LearnConfidenceFactory.Compute(Microsoft.ProgramSynthesis.Transformation.Formula.Semantics.Learning.Recognition,Microsoft.ProgramSynthesis.Transformation.Formula.Semantics.Learning.LearnOptions,System.Nullable{System.Threading.CancellationToken},Microsoft.ProgramSynthesis.Transformation.Formula.Semantics.Learning.LearnDebugTrace)">
            <summary>
                Returns a number that indicates if tokens in output are present in inputs or other outputs
            </summary>
            <returns>
                null if no examples or output is not a string, else number showing coverage
            </returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Learner">
            <summary>
                Class for learning <see cref="T:Microsoft.ProgramSynthesis.Transformation.Formula.Program" />.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Transformation.Formula.Learner.ScoreFeature">
            <summary>
                The ranking feature.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Learner.GetFeatureOptionsFor(System.Collections.Generic.IEnumerable{Microsoft.ProgramSynthesis.Wrangling.Constraints.Constraint{Microsoft.ProgramSynthesis.Wrangling.IRow,System.Object}},System.Collections.Generic.IEnumerable{Microsoft.ProgramSynthesis.Wrangling.IRow})">
            <summary>
                Compute the options to be passed down to the feature calculators for the given set of constraints and additional
                inputs.
            </summary>
            <param name="constraints">The constraints.</param>
            <param name="additionalInputs">The additional inputs.</param>
            <returns>An <see cref="T:Microsoft.ProgramSynthesis.Features.IFeatureOptions" /> object that can be used by feature calculators.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Learner.LearnAll(System.Collections.Generic.IEnumerable{Microsoft.ProgramSynthesis.Wrangling.Constraints.Constraint{Microsoft.ProgramSynthesis.Wrangling.IRow,System.Object}},System.Collections.Generic.IEnumerable{Microsoft.ProgramSynthesis.Wrangling.IRow},System.Threading.CancellationToken)">
            <inheritdoc />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Loader">
            <summary>
                Class for loading a <see cref="T:Microsoft.ProgramSynthesis.Transformation.Formula.Program" /> from its deserialized string.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Transformation.Formula.Loader.Instance">
            <summary>
                Singleton instance of <see cref="T:Microsoft.ProgramSynthesis.Transformation.Formula.Loader" />.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Loader.Create(Microsoft.ProgramSynthesis.AST.ProgramNode)">
            <inheritdoc />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Program">
            <summary>
                Represents a Transformation.Formula program.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Program.#ctor(Microsoft.ProgramSynthesis.AST.ProgramNode,System.Nullable{System.Double},Microsoft.ProgramSynthesis.Transformation.Formula.Semantics.Learning.Features.RankingDebugTrace)">
            <summary>
                Constructs a program.
            </summary>
            <param name="programNode">The program node.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Program.Equals(Microsoft.ProgramSynthesis.Transformation.Formula.Program)">
            <inheritdoc />
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Transformation.Formula.ExampleToken.End">
            <summary>
                End position (1-based)
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Transformation.Formula.ExampleToken.Start">
            <summary>
                Start position (1-based)
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.ProgramMetaFactory.HasConsistentInput">
            <summary>
                If all additional inputs have a value (not null), then the formula is considered to have consistent input
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.ProgramMetaFactory.HasConsistentOutput">
            <summary>
                If all additional output have a value (not null), then the formula is considered to have consistent output
            </summary>
            <returns></returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Session">
            <summary>
                A Transformation.Formula learning session. See <see cref="T:Microsoft.ProgramSynthesis.Wrangling.Session.Session`3" /> for the API for
                learning sessions.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Session.#ctor(Microsoft.ProgramSynthesis.Wrangling.Logging.ILogger,Microsoft.ProgramSynthesis.Wrangling.Session.IJournalStorage,System.Globalization.CultureInfo)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Session.#ctor(Microsoft.ProgramSynthesis.Transformation.Formula.Semantics.Learning.LearnDebugTrace,Microsoft.ProgramSynthesis.Transformation.Formula.Semantics.Learning.Features.RankingDebugTrace,Microsoft.ProgramSynthesis.Wrangling.Logging.ILogger,Microsoft.ProgramSynthesis.Wrangling.Session.IJournalStorage,System.Globalization.CultureInfo)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Session.SuggestOutput(Microsoft.ProgramSynthesis.Wrangling.IRow,Microsoft.ProgramSynthesis.Transformation.Formula.Semantics.Learning.Models.SuggestOutputOptions,System.Threading.CancellationToken)">
            <summary>
                Suggest output examples base on an <see cref="T:Microsoft.ProgramSynthesis.Wrangling.IRow" /> and user generated prefix string.
            </summary>
            <param name="inputRow">Input row used to generate the output suggestions.</param>
            <param name="options">Options indicating behaviors used to generate the suggestions</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Session.SuggestOutput(Microsoft.ProgramSynthesis.Wrangling.IRow,System.String,Microsoft.ProgramSynthesis.Transformation.Formula.Semantics.Learning.Models.SuggestOutputOptions,System.Threading.CancellationToken)">
            <summary>
                Suggest output examples base on an <see cref="T:Microsoft.ProgramSynthesis.Wrangling.IRow" /> and user generated prefix string.
            </summary>
            <param name="inputRow">Input row used to generate the output suggestions.</param>
            <param name="prefix">User generated prefix string.</param>
            <param name="options">Options indicating behaviors used to generate the suggestions</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Session.SuggestOutputTokens(Microsoft.ProgramSynthesis.Wrangling.IRow,Microsoft.ProgramSynthesis.Transformation.Formula.Semantics.Learning.Models.SuggestOutputOptions,System.Threading.CancellationToken)">
            <summary>
                Suggest all output examples base on an <see cref="T:Microsoft.ProgramSynthesis.Wrangling.IRow" />
            </summary>
            <param name="inputRow">Input row used to generate the output suggestions.</param>
            <param name="options">Options indicating behaviors used to generate the suggestions</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Session.WarmUp(System.Nullable{Microsoft.ProgramSynthesis.Translation.TargetLanguage},System.Collections.Generic.IEnumerable{System.Globalization.CultureInfo})">
            <summary>
                Populate static caches to reduce latency during the first call to Learn or LearnAndTranslate
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Session.LearnAndTranslate(Microsoft.ProgramSynthesis.Translation.TargetLanguage,Microsoft.ProgramSynthesis.Wrangling.Session.RankingMode,System.Threading.CancellationToken,System.Nullable{System.Guid})">
            <summary>
                Learn a program and translate it to the specified <see cref="T:Microsoft.ProgramSynthesis.Translation.TargetLanguage" />.
            </summary>
            <param name="target">Output Language</param>
            <param name="learnRankingMode">What "top" means.</param>
            <param name="cancellationToken">Allows for external cancellation of this operation. Defaults to a indefinite period.</param>
            <param name="guid">Correlation id for logging and telemetry.</param>
            <returns>Structured data containing the DSL program and target language program.</returns>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Session.Translate(Microsoft.ProgramSynthesis.Translation.TargetLanguage,Microsoft.ProgramSynthesis.Transformation.Formula.Program,System.Threading.CancellationToken)">
            <summary>
                Translate a program to the specified <see cref="T:Microsoft.ProgramSynthesis.Translation.TargetLanguage" />.
            </summary>
            <param name="target">Output Language</param>
            <param name="cancellationToken">Allows for external cancellation of this operation. Defaults to a indefinite period.</param>
            <returns>Structured data containing the DSL program and target language program.</returns>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.ConstraintCollectionExtensions.AddOrReplace``1(Microsoft.ProgramSynthesis.Utils.NotifyingCollection{Microsoft.ProgramSynthesis.Wrangling.Constraints.Constraint{Microsoft.ProgramSynthesis.Wrangling.IRow,System.Object}},``0)">
            <summary>
                Add or Replace a <seealso cref="!:IUniqueConstraint" /> in the constraint collection.
            </summary>
            <typeparam name="TConstraint"></typeparam>
            <param name="constraints"></param>
            <param name="constraint">Unique constraint to be added or replaced in the constraint collection.</param>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.AccumulateVisitor">
            <summary>
                Visitor that performs accumulation on a <see cref="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.FormulaExpression" />.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.AccumulateVisitor.Accumulate(Microsoft.ProgramSynthesis.Transformation.Formula.Translation.FormulaExpression,System.Action{Microsoft.ProgramSynthesis.Transformation.Formula.Translation.FormulaExpression},Microsoft.ProgramSynthesis.Transformation.Formula.Translation.AccumulateDirection)">
            <summary>
                Apply an accumulator function to the given <see cref="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.FormulaExpression" />
            </summary>
            <param name="expression"></param>
            <param name="accumulator">Accumulator Function</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.AccumulateVisitor.AccumulateBottomUp(Microsoft.ProgramSynthesis.Transformation.Formula.Translation.FormulaExpression,System.Action{Microsoft.ProgramSynthesis.Transformation.Formula.Translation.FormulaExpression})">
            <summary>
                Apply an accumulator function to the given <see cref="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.FormulaExpression" />
            </summary>
            <param name="expression"></param>
            <param name="accumulator">Accumulator Function</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.AccumulateVisitor.AccumulateTopDown(Microsoft.ProgramSynthesis.Transformation.Formula.Translation.FormulaExpression,System.Action{Microsoft.ProgramSynthesis.Transformation.Formula.Translation.FormulaExpression})">
            <summary>
                Apply an accumulator function to the given <see cref="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.FormulaExpression" />
            </summary>
            <param name="expression"></param>
            <param name="accumulator">Accumulator Function</param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.CSharp.CSharpProgram">
            <summary>
                CSharp program expression
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.CSharp.CSharpParenthesis">
            <inheritdoc />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.CSharp.CSharpRegexLiteral">
            <inheritdoc />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.CSharp.CSharpStringLiteral">
            <inheritdoc />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.CSharp.CSharpIntLiteral">
            <inheritdoc />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.CSharp.CSharpDateTime">
            <inheritdoc />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.CSharp.CSharpDateTimeLiteral">
            <inheritdoc />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.CSharp.CSharpUnaryMinus">
            <inheritdoc cref="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.FormulaExpression" />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.CSharp.CSharpMinus">
            <inheritdoc />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.CSharp.CSharpPlus">
            <inheritdoc />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.CSharp.CSharpMultiply">
            <inheritdoc />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.CSharp.CSharpDivide">
            <inheritdoc />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.CSharp.CSharpModulo">
            <inheritdoc />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.CSharp.CSharpExponent">
            <inheritdoc />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.CSharp.CSharpConcat">
            <inheritdoc />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.CSharp.CSharpAssign">
            <inheritdoc cref="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.FormulaExpression" />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.CSharp.CSharpEqual">
            <inheritdoc cref="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.FormulaExpression" />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.CSharp.CSharpNotEqual">
            <inheritdoc cref="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.FormulaExpression" />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.CSharp.CSharpAnd">
            <inheritdoc cref="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.FormulaExpression" />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.CSharp.CSharpOr">
            <inheritdoc cref="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.FormulaExpression" />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.CSharp.CSharpOrPattern">
            <inheritdoc cref="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.FormulaExpression" />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.CSharp.CSharpIs">
            <inheritdoc cref="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.FormulaExpression" />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.CSharp.CSharpGreaterThanEqual">
            <inheritdoc cref="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.FormulaExpression" />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.CSharp.CSharpLessThan">
            <inheritdoc cref="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.FormulaExpression" />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.CSharp.CSharpLessThanEqual">
            <inheritdoc cref="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.FormulaExpression" />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.CSharp.CSharpLambda">
            <inheritdoc />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.CSharp.CSharpStringRange">
            <inheritdoc />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.CSharp.CSharpIndex">
            <inheritdoc cref="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.FormulaExpression" />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.CSharp.CSharpRawSegment">
            <inheritdoc />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.CSharp.CSharpRawLine">
            <inheritdoc />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.CSharp.CSharpVariable">
            <inheritdoc cref="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.FormulaExpression" />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.CSharp.CSharpCast">
            <inheritdoc cref="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.FormulaExpression" />
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.CSharp.CSharpCast.Precedence">
            <inheritdoc />
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.CSharp.CSharpCast.Subject">
            <inheritdoc />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.CSharp.CSharpReturn">
            <inheritdoc cref="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.FormulaExpression" />
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.CSharp.CSharpReturn.Precedence">
            <inheritdoc />
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.CSharp.CSharpReturn.Subject">
            <inheritdoc />
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.CSharp.CSharpNot.Precedence">
            <inheritdoc />
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.CSharp.CSharpNot.Subject">
            <inheritdoc />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.CSharp.CSharpExpressionOptimizer">
            <summary>
                Applies optimization to a given <seealso cref="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.FormulaExpression" /> for CSharp.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.CSharp.CSharpExpressionOptimizer.ConsolidateCommonExpressions(Microsoft.ProgramSynthesis.Transformation.Formula.Translation.CSharp.CSharpMethod)">
            <summary>
                Perform common subexpression elimination.
            </summary>
            <param name="method"></param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.CSharp.CSharpProgramTranslator">
            <summary>
                Implements translation for Transformation.Formula programs into CSharp <see cref="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.FormulaExpression" />
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.CSharp.CSharpProgramTranslator.Translate(Microsoft.ProgramSynthesis.Transformation.Formula.Program,System.Collections.Generic.IEnumerable{Microsoft.ProgramSynthesis.Wrangling.Example},System.Collections.Generic.IEnumerable{Microsoft.ProgramSynthesis.Wrangling.IRow},Microsoft.ProgramSynthesis.Transformation.Formula.Translation.CSharp.ICSharpTranslationOptions,Microsoft.ProgramSynthesis.Wrangling.Logging.ILogger,System.Threading.CancellationToken)">
            <summary>
                Translates a Transformation.Formula program into a <see cref="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.CSharp.CSharpProgram" />
            </summary>
            <param name="program"></param>
            <param name="options"></param>
            <param name="logger"></param>
            <param name="cancellationToken"></param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.Excel.ExcelStringLiteral">
            <inheritdoc />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.Excel.ExcelFunc">
            <inheritdoc />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.Excel.ExcelLet">
            <inheritdoc />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.Excel.ExcelNumberLiteral">
            <inheritdoc />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.Excel.ExcelDateTimeLiteral">
            <inheritdoc />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.Excel.ExcelMinus">
            <inheritdoc />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.Excel.ExcelPlus">
            <inheritdoc />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.Excel.ExcelMultiply">
            <inheritdoc />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.Excel.ExcelDivide">
            <inheritdoc />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.Excel.ExcelGreaterThan">
            <inheritdoc cref="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.FormulaExpression" />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.Excel.ExcelGreaterThanEqual">
            <inheritdoc cref="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.FormulaExpression" />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.Excel.ExcelLessThan">
            <inheritdoc cref="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.FormulaExpression" />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.Excel.ExcelLessThanEqual">
            <inheritdoc cref="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.FormulaExpression" />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.Excel.ExcelConcat">
            <inheritdoc />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.Excel.ExcelVariable">
            <inheritdoc />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.Excel.ExcelRange">
            <inheritdoc />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.Excel.ExcelArray">
            <inheritdoc />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.Excel.ExcelDigitRange">
            <inheritdoc />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.Excel.ExcelEqual">
            <inheritdoc cref="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.FormulaExpression" />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.Excel.ExcelFilterAnd">
            <inheritdoc cref="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.FormulaExpression" />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.Excel.ExcelExpressionOptimizer">
            <summary>
                Applies optimization to a given <seealso cref="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.FormulaExpression" /> for Python.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.Excel.ExcelProgramTranslator">
            <summary>
                Implements translation for Transformation.Formula programs into Excel expressions
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.Excel.ExcelProgramTranslator.Translate(Microsoft.ProgramSynthesis.Transformation.Formula.Program,System.Collections.Generic.IEnumerable{Microsoft.ProgramSynthesis.Wrangling.Example},System.Collections.Generic.IEnumerable{Microsoft.ProgramSynthesis.Wrangling.IRow},Microsoft.ProgramSynthesis.Transformation.Formula.Translation.Excel.IExcelTranslationOptions,Microsoft.ProgramSynthesis.Wrangling.Logging.ILogger,System.Threading.CancellationToken)">
            <summary>
                Translates a Transformation.Formula program into an Excel <see cref="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.FormulaExpression" />
            </summary>
            <param name="program"></param>
            <param name="options"></param>
            <param name="logger"></param>
            <param name="cancellationToken"></param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.FormulaExpression">
            <summary>
                Base formula expression used by all Transformation.Formula expressions.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.FormulaExpression.CompareTo(Microsoft.ProgramSynthesis.Transformation.Formula.Translation.FormulaExpression)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.FormulaExpression.ToAnonymizedString">
            <summary>
                Returns a string that with masked values of literals and variables.
                For literals, upper case letters are converted to 'A',
                Lower case letters are converted to 'a',
                Numbers are converted to '9', Non-alphanumerics are preserved.
                Variables are converted to masked distinct names.
            </summary>
            <returns>
                A private string that represents this formula.
            </returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.FormulaFunc">
            <summary>
                Formula generic function
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.FormulaStringLiteral">
            <summary>
                Formula string
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.FormulaRawStringLiteral">
            <summary>
                Formula raw string
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.FormulaRegexLiteral">
            <summary>
                Formula regex
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.FormulaParenthesis">
            <summary>
                Formula parenthesis grouping
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.FormulaNumberLiteral">
            <summary>
                Formula number
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.FormulaBooleanLiteral">
            <summary>
                Formula boolean
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.FormulaDateTimeLiteral">
            <summary>
                Formula DateTime
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.FormulaMinus">
            <summary>
                Formula minus operator
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.FormulaPlus">
            <summary>
                Formula plus operator
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.FormulaVariable">
            <summary>
                Formula variable
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.FormulaRaw">
            <inheritdoc />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.FormulaExtractVisitor">
            <summary>
                Visitor that extracts a list of expressions that match a given predicate.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.FormulaSubstitutionVisitor">
            <summary>
                Visitor that performs expression substitution on a <see cref="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.FormulaExpression" />.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.FormulaTransformVisitor">
            <summary>
                Visitor that performs expression transformation on a <see cref="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.FormulaExpression" />.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.FormulaTransformVisitor.Transform(Microsoft.ProgramSynthesis.Transformation.Formula.Translation.FormulaExpression,System.Func{Microsoft.ProgramSynthesis.Transformation.Formula.Translation.FormulaExpression,Microsoft.ProgramSynthesis.Transformation.Formula.Translation.FormulaTransformNodeInfo,Microsoft.ProgramSynthesis.Transformation.Formula.Translation.FormulaExpression})">
            <summary>
                Apply a transform function to the given <see cref="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.FormulaExpression" />
            </summary>
            <param name="expression"></param>
            <param name="transform">Transform Function</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.FormulaTransformVisitor.Transform(Microsoft.ProgramSynthesis.Transformation.Formula.Translation.FormulaExpression,System.Func{Microsoft.ProgramSynthesis.Transformation.Formula.Translation.FormulaExpression,Microsoft.ProgramSynthesis.Transformation.Formula.Translation.FormulaExpression})">
            <summary>
                Apply a transform function to the given <see cref="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.FormulaExpression" />
            </summary>
            <param name="expression"></param>
            <param name="transform">Transform Function</param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.IFormulaVisitor`1">
            <summary>
                Generic visitor <see cref="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.FormulaExpression" />
            </summary>
            <typeparam name="T">Aggregate acceptance type resulting from a visit.</typeparam>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.IFormulaVisitor">
            <summary>
                Accumulation visitor <see cref="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.FormulaExpression" />
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.PowerQuery.OutputType.LambdaExpression">
            <summary>
            The default output type of the translation is a lambda expression.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.PowerQuery.OutputType.InnerExpression">
            <summary>
            Return just the inner expression, without wrapping it in a lambda expression.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.PowerQuery.PowerQueryLambdaFunction">
            <summary>
                An anonymous function of either "each ..." or "() =>" form.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.PowerQuery.PowerQueryLambdaFunction.Parameters">
            <summary>
                If parameters list is <c>null</c>, then the function is of the "each ..." form
                which has the single implicit parameter <c>_</c>.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.PowerQuery.PowerQueryParenthesis">
            <inheritdoc />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.PowerQuery.PowerQueryFunc">
            <inheritdoc cref="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.FormulaFunc" />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.PowerQuery.PowerQueryDateTimeLiteral">
            <inheritdoc />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.PowerQuery.PowerQueryBooleanLiteral">
            <inheritdoc />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.PowerQuery.PowerQueryNumberLiteral">
            <inheritdoc />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.PowerQuery.PowerQueryNullLiteral">
            <inheritdoc />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.PowerQuery.PowerQueryList">
            <inheritdoc />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.PowerQuery.PowerQueryMinus">
            <inheritdoc />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.PowerQuery.PowerQueryPlus">
            <inheritdoc />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.PowerQuery.PowerQueryMultiply">
            <inheritdoc />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.PowerQuery.PowerQueryDivide">
            <inheritdoc />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.PowerQuery.PowerQueryConcat">
            <inheritdoc />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.PowerQuery.PowerQueryVariable">
            <inheritdoc />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.PowerQuery.PowerQueryRecord">
            <inheritdoc />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.PowerQuery.PowerQueryEqual">
            <inheritdoc cref="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.FormulaExpression" />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.PowerQuery.PowerQueryAnd">
            <inheritdoc cref="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.FormulaExpression" />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.PowerQuery.PowerQueryOr">
            <inheritdoc cref="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.FormulaExpression" />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.PowerQuery.PowerQueryGreaterThan">
            <inheritdoc cref="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.FormulaExpression" />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.PowerQuery.PowerQueryGreaterThanEqual">
            <inheritdoc cref="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.FormulaExpression" />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.PowerQuery.PowerQueryLessThan">
            <inheritdoc cref="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.FormulaExpression" />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.PowerQuery.PowerQueryLessThanEqual">
            <inheritdoc cref="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.FormulaExpression" />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.PowerQuery.PowerQueryNot">
            <inheritdoc cref="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.FormulaExpression" />
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.PowerQuery.PowerQueryNot.Precedence">
            <inheritdoc />
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.PowerQuery.PowerQueryNot.Subject">
            <inheritdoc />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.PowerQuery.PowerQueryUnaryMinus">
            <inheritdoc cref="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.FormulaExpression" />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.PowerQuery.PowerQueryStringLiteral">
            <inheritdoc />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.PowerQuery.PowerQueryLocale">
            <inheritdoc />
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.PowerQuery.PowerQueryLookup.Type">
            <inheritdoc />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.PowerQuery.PowerQueryExpressionOptimizer">
            <summary>
                Applies optimization to a given <seealso cref="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.FormulaExpression" /> for Python.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.PowerQuery.PowerQueryProgramTranslator">
            <summary>
                Implements translation for Transformation.Formula programs into PowerQuery expressions.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.PowerQuery.PowerQueryProgramTranslator.Translate(Microsoft.ProgramSynthesis.Transformation.Formula.Program,System.Collections.Generic.IEnumerable{Microsoft.ProgramSynthesis.Wrangling.Example},System.Collections.Generic.IEnumerable{Microsoft.ProgramSynthesis.Wrangling.IRow},Microsoft.ProgramSynthesis.Transformation.Formula.Translation.PowerQuery.IPowerQueryTranslationOptions,Microsoft.ProgramSynthesis.Wrangling.Logging.ILogger,System.Threading.CancellationToken)">
            <summary>
                Translates a Transformation.Formula program into a PowerQuery <see cref="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.FormulaExpression" />
            </summary>
            <param name="program"></param>
            <param name="options"></param>
            <param name="logger"></param>
            <param name="cancellationToken"></param>
            <returns></returns>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.Python.ILocalizedStrings.Output">
            <summary>
                Localized string for "Output"
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.Python.ILocalizedStrings.TransformationCodeCommentPrefix">
            <summary>
                Localized string for "Transform based on the following examples"
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.Python.PandasColumn">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.Python.PandasColumn.ToCodeString">
            <inheritdoc />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.Python.PandasExpressionOptimizer">
            <summary>
                Applies optimization to a given <seealso cref="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.FormulaExpression" /> for Pandas.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.Python.PandasExpressionOptimizer.UseSeriesFunctions(Microsoft.ProgramSynthesis.Transformation.Formula.Translation.Python.PythonDefinition)">
            <summary>
                Apply Pandas str series function to all applicable nodes.
            </summary>
            <param name="definition"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.Python.PandasProgramTranslator.Translate(Microsoft.ProgramSynthesis.Transformation.Formula.Program,Microsoft.ProgramSynthesis.Transformation.Formula.Translation.Python.IPandasTranslationOptions,System.Boolean,System.Collections.Generic.IEnumerable{Microsoft.ProgramSynthesis.Wrangling.Example},System.Collections.Generic.IEnumerable{Microsoft.ProgramSynthesis.Wrangling.IRow},Microsoft.ProgramSynthesis.Wrangling.Logging.ILogger,System.Threading.CancellationToken)">
            <summary>
                Translates a Transformation.Formula program into a Pandas <see cref="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.Python.PythonProgram" />
            </summary>
            <param name="program"></param>
            <param name="options"></param>
            <param name="logger"></param>
            <param name="cancellationToken"></param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.Python.PySparkExpressionOptimizer">
            <summary>
                Applies optimization to a given <seealso cref="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.FormulaExpression" /> for PySpark.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.Python.PythonProgram">
            <summary>
                Python program expression
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.Python.PythonComment.#ctor(System.String,Microsoft.ProgramSynthesis.Transformation.Formula.Translation.Python.PythonCommentType)">
            <summary>
                Creates a comment block.
            </summary>
            <param name="comment">The lines of comments in the comment block.</param>
            <remarks>
                <paramref name="comment" /> should not contain '#', '"""' or indents; these will
                be added at rendering time.
            </remarks>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.Python.PythonLambda">
            <inheritdoc />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.Python.PythonInterpolatedFormat">
            <inheritdoc />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.Python.PythonParenthesis">
            <inheritdoc />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.Python.PythonRegexLiteral">
            <inheritdoc />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.Python.PythonStringLiteral">
            <inheritdoc />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.Python.PythonIntLiteral">
            <inheritdoc />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.Python.PythonMinus">
            <inheritdoc />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.Python.PythonPlus">
            <inheritdoc />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.Python.PythonMultiply">
            <inheritdoc />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.Python.PythonDivide">
            <inheritdoc />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.Python.PythonDivideFloor">
            <inheritdoc />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.Python.PythonModulo">
            <inheritdoc />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.Python.PythonExponent">
            <inheritdoc />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.Python.PythonConcat">
            <inheritdoc />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.Python.PythonArray">
            <inheritdoc />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.Python.PythonAssign">
            <inheritdoc cref="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.FormulaExpression" />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.Python.PythonIs">
            <inheritdoc cref="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.FormulaExpression" />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.Python.PythonEqual">
            <inheritdoc cref="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.FormulaExpression" />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.Python.PythonNotEqual">
            <inheritdoc cref="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.FormulaExpression" />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.Python.PythonAnd">
            <inheritdoc cref="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.FormulaExpression" />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.Python.PythonOr">
            <inheritdoc cref="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.FormulaExpression" />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.Python.PythonGreaterThan">
            <inheritdoc cref="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.FormulaExpression" />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.Python.PythonGreaterThanEqual">
            <inheritdoc cref="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.FormulaExpression" />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.Python.PythonLessThan">
            <inheritdoc cref="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.FormulaExpression" />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.Python.PythonLessThanEqual">
            <inheritdoc cref="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.FormulaExpression" />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.Python.PythonIndexRange">
            <inheritdoc />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.Python.PythonIndex">
            <inheritdoc cref="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.FormulaExpression" />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.Python.PythonRawSegment">
            <inheritdoc />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.Python.PythonRaw">
            <inheritdoc />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.Python.PythonReturn">
            <inheritdoc cref="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.FormulaExpression" />
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.Python.PythonReturn.Precedence">
            <inheritdoc />
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.Python.PythonReturn.Subject">
            <inheritdoc />
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.Python.PythonNot.Precedence">
            <inheritdoc />
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.Python.PythonNot.Subject">
            <inheritdoc />
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.Python.PythonNegate.Precedence">
            <inheritdoc />
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.Python.PythonNegate.Subject">
            <inheritdoc />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.Python.PythonExpressionOptimizer">
            <summary>
                Applies optimization to a given <seealso cref="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.FormulaExpression" /> for Python.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.Python.PythonExpressionOptimizer.UseInlineFunctions(Microsoft.ProgramSynthesis.Transformation.Formula.Translation.Python.PythonProgram)">
            <summary>
                Inlines functions where possible, i.e. when the definitions are single-lined.
            </summary>
            <param name="program"></param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.Python.PythonProgramTranslator">
            <summary>
                Implements translation for Transformation.Formula programs into Python <see cref="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.FormulaExpression" />
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.Python.PythonProgramTranslator.Translate(Microsoft.ProgramSynthesis.Transformation.Formula.Program,System.Collections.Generic.IEnumerable{Microsoft.ProgramSynthesis.Wrangling.Example},System.Collections.Generic.IEnumerable{Microsoft.ProgramSynthesis.Wrangling.IRow},Microsoft.ProgramSynthesis.Transformation.Formula.Translation.Python.IPythonTranslationOptions,System.Boolean,Microsoft.ProgramSynthesis.Wrangling.Logging.ILogger,System.Threading.CancellationToken)">
            <summary>
                Translates a Transformation.Formula program into a <see cref="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.Python.PythonProgram" />
            </summary>
            <param name="program"></param>
            <param name="options"></param>
            <param name="examples"></param>
            <param name="logger"></param>
            <param name="cancellationToken"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.Python.PythonProgramTranslator.ResolveIdentifierName(System.String,System.String)">
            <summary>
                Ensures that identifier names are valid according to
                https://docs.python.org/3/reference/lexical_analysis.html#grammar-token-identifier.
                If not, uses some heuristics to try to correct them, or return the <paramref name="defaultIdentifierName" />
                if no corrections are found, or null if <paramref name="defaultIdentifierName" /> is not specified.
            </summary>
            <remarks>
                <paramref name="defaultIdentifierName" /> is not validated by this method.
            </remarks>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.Sql.SqlStringLiteral">
            <inheritdoc />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.Sql.SqlParenthesis">
            <inheritdoc />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.Sql.SqlFunc">
            <inheritdoc />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.Sql.SqlNumberLiteral">
            <inheritdoc />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.Sql.SqlMinus">
            <inheritdoc />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.Sql.SqlPlus">
            <inheritdoc />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.Sql.SqlMultiply">
            <inheritdoc />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.Sql.SqlDivide">
            <inheritdoc />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.Sql.SqlConcat">
            <inheritdoc />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.Sql.SqlType">
            <summary>
                SQL types, used to annotate Variable nodes, as their type information
                is required to properly instantiate table schemas in the "computed column" use case.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.Sql.SqlTryParse">
            <summary>
                TRY_PARSE has custom syntax in SQL SERVER, so while it behaves like a function, it
                requires that we emit code that follows a different syntax.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.Sql.SqlExpressionOptimizer">
            <summary>
                Applies <see cref="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.Sql.SqlOptimizations" /> to a given <seealso cref="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.FormulaExpression" />
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.Sql.SqlExpressionOptimizer.Optimize(Microsoft.ProgramSynthesis.Transformation.Formula.Translation.FormulaExpression,Microsoft.ProgramSynthesis.Transformation.Formula.Translation.Sql.ISqlTranslationOptions)">
            <summary>
                Perform <see cref="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.Sql.SqlOptimizations" /> on the given <seealso cref="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.FormulaExpression" />.
            </summary>
            <param name="expression"></param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.Sql.SqlProgramTranslator">
            <summary>
                Implements translation for Transformation.Formula programs into Sql expressions
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.Sql.SqlProgramTranslator.Translate(Microsoft.ProgramSynthesis.Transformation.Formula.Program,Microsoft.ProgramSynthesis.Transformation.Formula.Translation.Sql.ISqlTranslationOptions,System.Collections.Generic.IEnumerable{Microsoft.ProgramSynthesis.Wrangling.Example},System.Collections.Generic.IEnumerable{Microsoft.ProgramSynthesis.Wrangling.IRow},Microsoft.ProgramSynthesis.Wrangling.Logging.ILogger,System.Threading.CancellationToken)">
            <summary>
                Translates a Transformation.Formula program into a SQL <see cref="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.FormulaExpression" />
            </summary>
            <param name="program"></param>
            <param name="options"></param>
            <param name="logger"></param>
            <param name="cancellationToken"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.Sql.SqlProgramTranslator.Translate(Microsoft.ProgramSynthesis.AST.ProgramNode,System.Threading.CancellationToken)">
            <summary>
                Translates a Transformation.Formula program into a Sql expression.
            </summary>
            <param name="node"></param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.TranslationMetaFactory">
            <summary>
                Computes metadata from a <see cref="T:Microsoft.ProgramSynthesis.Transformation.Formula.Translation.FormulaExpression" />
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Semantics.Extensions.ObjectExtension.ToPythonPseudoLiteral(System.Object)">
            <summary>
                Renders the subject as a string suitable for use in comments are display text.
            </summary>
            <param name="subject"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Semantics.Extensions.ObjectExtension.ToCSharpLiteral(System.Object)">
            <summary>
                Renders the subject as a string suitable for use in code.
            </summary>
            <param name="subject"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Semantics.Extensions.ObjectExtension.ToCSharpLiteral(System.Int32)">
            <summary>
                Renders the subject as a string suitable for use in code.
            </summary>
            <param name="subject"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Semantics.Extensions.ObjectExtension.ToCSharpLiteral(System.Double)">
            <summary>
                Renders the subject as a string suitable for use in code.
            </summary>
            <param name="subject"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Semantics.Extensions.ObjectExtension.ToCSharpLiteral(System.Decimal)">
            <summary>
                Renders the subject as a string suitable for use in code.
            </summary>
            <param name="subject"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Semantics.Extensions.ObjectExtension.ToCSharpPseudoLiteral(System.Object)">
            <summary>
                Renders the subject as a string suitable for use in comments or display text.
            </summary>
            <param name="subject"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Semantics.Learning.Concat.OutputToken.Equals(Microsoft.ProgramSynthesis.Transformation.Formula.Semantics.Learning.Concat.OutputToken)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Semantics.Learning.Concat.OutputToken.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Semantics.Learning.Concat.OutputToken.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Semantics.Learning.Concat.FormattedNumberOutputToken.IsCompatible(Microsoft.ProgramSynthesis.Transformation.Formula.Semantics.Learning.Concat.OutputToken)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Semantics.Learning.Concat.FormattedDateTimeOutputToken.IsCompatible(Microsoft.ProgramSynthesis.Transformation.Formula.Semantics.Learning.Concat.OutputToken)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Semantics.Learning.Concat.SubstringOutputToken.IsCompatible(Microsoft.ProgramSynthesis.Transformation.Formula.Semantics.Learning.Concat.OutputToken)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Semantics.Learning.Concat.ConstantStringOutputToken.IsCompatible(Microsoft.ProgramSynthesis.Transformation.Formula.Semantics.Learning.Concat.OutputToken)">
            <inheritdoc />
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Transformation.Formula.Semantics.Learning.Conditionals.ProgramFirst.Models.ConditionalCluster.Predicates">
            <summary>
                All predicates generated by this cluster. Some predicates may not uniquely identify this cluster.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Transformation.Formula.Semantics.Learning.Conditionals.ProgramFirst.Models.ConditionalCluster.ValidPredicates">
            <summary>
                Predicates that uniquely identify this cluster.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Semantics.Learning.Features.RankingRatioFeatureBase.InverseProportion(System.Double,System.Int32)">
            <summary>
                Returns a value from 0.0 to 1.0 corresponding to the inverse proportion of <paramref name="value" /> to
                <paramref name="maxValue" />.
            </summary>
            <param name="value"></param>
            <param name="maxValue"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Semantics.Learning.Features.RankingRatioFeatureBase.Proportion(System.Double,System.Double)">
            <summary>
                Returns a value from 0.0 to 1.0 corresponding to the proportion of <paramref name="value" /> to
                <paramref name="maxValue" />.
            </summary>
            <param name="value"></param>
            <param name="maxValue"></param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Semantics.Learning.Features.RankingScoreFeature">
            <summary>
                Ranking Algorithm:
                <br />
                <br />
                1. Award a normalized score based on all leaf values present in the program. Leaf values are composed of both
                literals and variables. Ratios must be between 0 and 1. To customize the award ratio use
                <see cref="T:Microsoft.ProgramSynthesis.Transformation.Formula.Semantics.Learning.Features.RankingAwardRatioFeature" />
                <br />
                <br />
                2. Compute the sum of penalty ratio values based on the literals present in the program. Generally this step is
                used to penalize undesirable operators and literals such as constant strings. Penalty ratios can be adjusted by
                using
                <see cref="T:Microsoft.ProgramSynthesis.Transformation.Formula.Semantics.Learning.Features.RankingPenaltyRatioFeature" />
                <br />
                <br />
                4. Compute the final score:
                Avg(LeafAwardScoreRatio) * AwardRange) - (Sum(PenaltyRatios) * Penalty
                <br />
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Semantics.Learning.TimedEvent.Dispose">
            <inheritdoc />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Semantics.Learning.LearnOptions">
            <summary>
                Holds the synthesis options.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Transformation.Formula.Semantics.Learning.LearnOptions.ColumnNamePriority">
            <summary>
                Indicates the priority order for columns during learning. If 2 or more columns can be used in a program, the column
                appearing first in the list will be used.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Transformation.Formula.Semantics.Learning.LearnOptions.ConditionalBranchMinExampleCount">
            <summary>
                Minimum example count required to establish a conditional cluster. Each true and false branch of a conditional
                statement must have at least ConditionalClusterMinExampleCount example.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Transformation.Formula.Semantics.Learning.LearnOptions.ConditionalMaxBranches">
            <summary>
                Maximum number of conditional clusters to be learned. Limits the number of conditional branches in a program.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Transformation.Formula.Semantics.Learning.LearnOptions.DataCultures">
            <summary>
                Cultures used for Date and Number recognition. Cultures are prioritized in the order available in this list.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Transformation.Formula.Semantics.Learning.LearnOptions.EnableConditional">
            <summary>
                Enable conditional expression learning
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Transformation.Formula.Semantics.Learning.LearnConfidenceBehavior.None">
            <summary>
                No Action
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Transformation.Formula.Semantics.Learning.LearnConfidenceBehavior.Predict">
            <summary>
                Only predict and log confidence value
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Transformation.Formula.Semantics.Learning.LearnConfidenceBehavior.Suppress">
            <summary>
                Suppress learn if the confidence score is lower than LearnConstraint.MinLearnConfidence
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Semantics.Learning.Models.ArithmeticSet.Equals(Microsoft.ProgramSynthesis.Transformation.Formula.Semantics.Learning.Models.ArithmeticSet)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Semantics.Learning.Models.ArithmeticSet.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Semantics.Learning.Models.ArithmeticSet.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Semantics.Learning.Models.DateTimeDescriptor.IsCompatible(Microsoft.ProgramSynthesis.Transformation.Formula.Semantics.Learning.Models.ProgramDescriptor)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Semantics.Learning.Models.FormatNumberDescriptor.IsCompatible(Microsoft.ProgramSynthesis.Transformation.Formula.Semantics.Learning.Models.ProgramDescriptor)">
            <inheritdoc />
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Transformation.Formula.Semantics.Learning.Models.InputValueList`2.Item(System.Int32)">
            <inheritdoc />
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Transformation.Formula.Semantics.Learning.Models.InputValueList`2.Count">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Semantics.Learning.Models.InputValueList`2.GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Semantics.Learning.Models.InputValueList`2.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Semantics.Learning.Models.ReverseLookupResult.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Semantics.Learning.Models.ReadOnlyListBase`1.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Semantics.Learning.Models.RoundDateTimeDescriptor">
            <summary>
                Describes options for the RoundDateTime operator.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Transformation.Formula.Semantics.Learning.Models.RoundDateTimeDescriptor.Mode">
            <summary>
                Rounding mode used by the RoundDateTime operator
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Transformation.Formula.Semantics.Learning.Models.RoundDateTimeDescriptor.Period">
            <summary>
                Period used by the RoundDateTime operator
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Semantics.Learning.Models.SubstringDescriptor.IsCompatible(Microsoft.ProgramSynthesis.Transformation.Formula.Semantics.Learning.Models.ProgramDescriptor)">
            <inheritdoc />
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Transformation.Formula.Semantics.Learning.Models.SuggestOutputOptions.DateMatch">
            <summary>
                Controls the matching algorithm for date recognition. SuggestOutputDateMatch.StartsWith will match only the
                beginning of a suggestion. SuggestOutputDateMatch.Contains will match any part of a suggestion.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Transformation.Formula.Semantics.Learning.Models.SuggestOutputOptions.SubstringLimit">
            <summary>
                Limits the number of substring suggestions.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Transformation.Formula.Semantics.Learning.Models.SuggestOutputOptions.SubstringLimitDefault">
            <summary>
                Limits the number of default substring suggestions.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Transformation.Formula.Semantics.Learning.Models.SuggestOutputOptions.SuggestionCultures">
            <summary>
                Culture used in suggested output for dates and number formatting.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Transformation.Formula.Semantics.Learning.Models.SuggestOutputOptions.SuggestionLimit">
            <summary>
                Limits the total number of suggestions.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Transformation.Formula.Semantics.Learning.Models.SuggestOutputOptions.SuggestionLocales">
            <summary>
                Locale used in suggested output for dates and number formatting. For example: en-US
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Transformation.Formula.Semantics.Learning.Models.SuggestOutputDateMatch.StartsWith">
            <summary>
                Only find dates that start with the supplied prefix.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Transformation.Formula.Semantics.Learning.Models.SuggestOutputDateMatch.Contains">
            <summary>
                Find dates that contain the supplied prefix.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Semantics.Learning.Models.Time">
            <summary>
                Represents a time of day. Used as an input type inside IRow.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Semantics.Learning.Models.Time.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
                Create a time from constituents.
            </summary>
            <param name="hour">0 to 23 hour value</param>
            <param name="minute">0 to 59 minute value</param>
            <param name="second">0 to 59 second value</param>
            <exception cref="T:System.ArgumentException"></exception>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Semantics.Learning.Recognition.InputNumberSets824(Microsoft.ProgramSynthesis.Wrangling.IRow)">
            <summary>
                Generate all possible combinations of number column values.
            </summary>
            <param name="inputRow"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Semantics.Learning.Recognition.NumberPairSources824(Microsoft.ProgramSynthesis.Wrangling.IRow)">
            <summary>
                Generate pairs used for Binary Arithmetic operators.
            </summary>
            <param name="inputRow"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Semantics.Learning.Recognition.ArithmeticSourceSets(Microsoft.ProgramSynthesis.Wrangling.IRow)">
            <summary>
                Generate all possible combinations of number column values.
            </summary>
            <param name="inputRow"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Semantics.Learning.Recognition.ArithmeticSourcePairs(Microsoft.ProgramSynthesis.Wrangling.IRow)">
            <summary>
                Generate pairs used for Binary Arithmetic operators.
            </summary>
            <param name="inputRow"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Semantics.Learning.Recognition.InputStrings(Microsoft.ProgramSynthesis.Wrangling.IRow,System.Collections.Generic.IEnumerable{System.String})">
            <summary>
                Returns all <see cref="T:System.String" /> input values found in the <see cref="!:inputRow" />.
            </summary>
            <param name="inputRow"></param>
            <param name="columnNames"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Semantics.Learning.Recognition.OutputStrings">
            <summary>
                Retrieve all <see cref="T:System.String" /> output values.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Semantics.Learning.Recognition.FindParseableDateTimes(System.String,System.Boolean)">
            <summary>
                Scan <see cref="!:subject" /> for parseable <see cref="T:System.DateTime" /> values.
            </summary>
            <param name="subject"></param>
            <param name="allowPartial"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Semantics.Learning.Recognition.FindDateTimes(System.String,System.Boolean,Microsoft.ProgramSynthesis.Transformation.Formula.Semantics.Learning.Recognition.FindDateTimeKind)">
            <summary>
                Scan <see cref="!:subject" /> for parseable <see cref="T:System.DateTime" /> values.
            </summary>
            <param name="subject"></param>
            <param name="allowPartial"></param>
            <param name="kind"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Semantics.Learning.Recognition.UniqueSubstrings(System.String,System.String)">
            <summary>
                Find unique substrings in the <paramref name="left" /> text as compared to the <paramref name="right" /> text.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Semantics.Learning.Recognition.TryGetMaxCommonSubstring(Microsoft.ProgramSynthesis.DslLibrary.Substring,Microsoft.ProgramSynthesis.DslLibrary.Substring,Microsoft.ProgramSynthesis.DslLibrary.Substring@,Microsoft.ProgramSynthesis.DslLibrary.Substring@)">
            <summary>
                Produces the longest substring that is common between the two input strings.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Semantics.Learning.Recognition.ExpandInstance(System.String,System.String,System.Int32)">
            <summary>
                Expand to positive and negative instances
            </summary>
            <param name="subject"></param>
            <param name="delimiter"></param>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Semantics.Learning.Recognition.ExpandPosition(System.String,System.Int32)">
            <summary>
                Expand to positive and negative positions.
            </summary>
            <param name="subject"></param>
            <param name="position"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Semantics.Learning.Tactics.DisableTactic.LearnAlternative(Microsoft.ProgramSynthesis.IAlternatingLanguage,System.Func{Microsoft.ProgramSynthesis.ILanguage,Microsoft.ProgramSynthesis.VersionSpace.ProgramSet})">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Semantics.Learning.Witness.ResolveRowNumberDisjunctiveExamples``1(System.Collections.Generic.IReadOnlyList{Microsoft.ProgramSynthesis.Transformation.Formula.Semantics.Learning.WitnessDisjunctiveContext{``0}})">
            <summary>
                Extract numbered row disjunctive examples from disjunctive witness contexts and perform input checks.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Transformation.Formula.Semantics.Operators">
            <summary>
                The implementation of the operators in the Transformation.Formula language.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Semantics.Operators.Abs(System.String,System.Int32)">
            <summary>
                Identifies an absolute position in the subject string (1 based). Always returns a positive position.
            </summary>
            <param name="subject">Source string</param>
            <param name="position">Position in the subject (1 based)</param>
            <returns>Position in the subject string, always positive</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Semantics.Operators.Find(System.String,System.String,System.Int32,System.Int32)">
            <summary>
                Find a position in the subject string based on a single character delimiter.
            </summary>
            <param name="subject">Source string</param>
            <param name="delimiter">Single character separator used to parse the subject string</param>
            <param name="instance">1-based index indicating the desired occurrence of the delimiter</param>
            <param name="findOffsetK">Adjustment applied to the delimiter position, can be positive or negative</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Semantics.Operators.Slice(System.String,System.Int32,System.Int32)">
            <summary>
                Produces a substring between the startPos and endPosition.
            </summary>
            <param name="subject"></param>
            <param name="startPosition">
                Inclusive starting position (1 based), must be positive, non-zero and less than the length + 1
                of subject.
            </param>
            <param name="endPosition">
                Exclusive ending position (1 based), must be positive, non-zero, less than the length of
                subject and greater than startPosition.
            </param>
            <returns>Substring between startPosition and endPosition</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Semantics.Operators.SliceBetween(System.String,System.String,System.String)">
            <summary>
                Produces a substring between the startText and endText.
            </summary>
            <param name="subject"></param>
            <param name="startText"></param>
            <param name="endText"></param>
            <returns>Substring between startText and endText</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Semantics.Operators.SlicePrefix(System.String,System.Int32)">
            <summary>
                Produces a substring starting at the beginning of the subject and ending at the position.
            </summary>
            <param name="subject"></param>
            <param name="position">
                Exclusive ending position (1 based), must be positive, non-zero, less than the length of
                subject and greater than 0.
            </param>
            <returns>Substring between startPosition and endPosition</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Semantics.Operators.SlicePrefixAbs(System.String,System.Int32)">
            <summary>
                Produces a substring starting at the beginning of the subject and ending at the position.
            </summary>
            <param name="subject"></param>
            <param name="position">
                Exclusive ending position (1 based), must be positive, non-zero, less than the length of
                subject and greater than 0.
            </param>
            <returns>Substring between startPosition and endPosition</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Semantics.Operators.SliceSuffix(System.String,System.Int32)">
            <summary>
                Produces a substring between the position and the end of the subject.
            </summary>
            <param name="subject"></param>
            <param name="position">
                Inclusive starting position (1 based), must be positive, non-zero and less than the length + 1
                of subject.
            </param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Semantics.Operators.Split(System.String,System.String,System.Int32)">
            <summary>
                Find a segment in the subject string based on a single character delimiter.
            </summary>
            <param name="subject">Source string</param>
            <param name="delimiter">Single character separator used to parse the subject string</param>
            <param name="instance">1-based index indicating the desired segment</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Semantics.Operators.Replace(System.String,System.String,System.String)">
            <summary>
                Replace text in the subject string.
            </summary>
            <param name="subject"></param>
            <param name="findText"></param>
            <param name="replaceText"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Semantics.Operators.If(System.Nullable{System.Boolean},System.Object,System.Object)">
            <summary>
                The conditional operator, which returns one of two values depending on the value of a Boolean condition.
            </summary>
            <param name="predicate">The condition.</param>
            <param name="trueBranch">Returned when predicate is True</param>
            <param name="falseBranch">Returned when predicate is False</param>
            <returns>
                Returns <paramref name="trueBranch" /> if <paramref name="predicate" /> == true, <paramref name="falseBranch" />
                otherwise.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Semantics.TimeWatch.Dispose">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Semantics.Utils.ExpandWhitespace(System.String,System.String,System.Int32)">
            <summary>
                Returns a substring which includes the substring argument and any leading or trailing whitespace found in the
                subject.
            </summary>
            <param name="subject"></param>
            <param name="substring"></param>
            <param name="startIndex"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Build.GrammarBuilders.Nodes.NodeRules.If(Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.condition,Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.result,Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.result)">
            <summary> Build a typed program node correponding to the If rule.</summary>
            <remarks>
                The return type could be RuleNodeTypes.If, but it is useful in more cases to already
                apply the implicit conversion to NodeTypes.result.
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Build.GrammarBuilders.Nodes.NodeRules.ToInt(Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.outNumber)">
            <summary> Build a typed program node correponding to the ToInt rule.</summary>
            <remarks>
                The return type could be RuleNodeTypes.ToInt, but it is useful in more cases to already
                apply the implicit conversion to NodeTypes.output.
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Build.GrammarBuilders.Nodes.NodeRules.ToDouble(Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.outNumber)">
            <summary> Build a typed program node correponding to the ToDouble rule.</summary>
            <remarks>
                The return type could be RuleNodeTypes.ToDouble, but it is useful in more cases to already
                apply the implicit conversion to NodeTypes.output.
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Build.GrammarBuilders.Nodes.NodeRules.ToDecimal(Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.outNumber)">
            <summary> Build a typed program node correponding to the ToDecimal rule.</summary>
            <remarks>
                The return type could be RuleNodeTypes.ToDecimal, but it is useful in more cases to already
                apply the implicit conversion to NodeTypes.output.
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Build.GrammarBuilders.Nodes.NodeRules.ToDateTime(Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.outDate)">
            <summary> Build a typed program node correponding to the ToDateTime rule.</summary>
            <remarks>
                The return type could be RuleNodeTypes.ToDateTime, but it is useful in more cases to already
                apply the implicit conversion to NodeTypes.output.
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Build.GrammarBuilders.Nodes.NodeRules.ToStr(Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.outStr)">
            <summary> Build a typed program node correponding to the ToStr rule.</summary>
            <remarks>
                The return type could be RuleNodeTypes.ToStr, but it is useful in more cases to already
                apply the implicit conversion to NodeTypes.output.
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Build.GrammarBuilders.Nodes.NodeRules.Replace(Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.fromStr,Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.replaceFindText,Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.replaceText)">
            <summary> Build a typed program node correponding to the Replace rule.</summary>
            <remarks>
                The return type could be RuleNodeTypes.Replace, but it is useful in more cases to already
                apply the implicit conversion to NodeTypes.outStr.
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Build.GrammarBuilders.Nodes.NodeRules.LowerCase(Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.segment)">
            <summary> Build a typed program node correponding to the LowerCase rule.</summary>
            <remarks>
                The return type could be RuleNodeTypes.LowerCase, but it is useful in more cases to already
                apply the implicit conversion to NodeTypes.segmentCase.
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Build.GrammarBuilders.Nodes.NodeRules.UpperCase(Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.segment)">
            <summary> Build a typed program node correponding to the UpperCase rule.</summary>
            <remarks>
                The return type could be RuleNodeTypes.UpperCase, but it is useful in more cases to already
                apply the implicit conversion to NodeTypes.segmentCase.
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Build.GrammarBuilders.Nodes.NodeRules.ProperCase(Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.segment)">
            <summary> Build a typed program node correponding to the ProperCase rule.</summary>
            <remarks>
                The return type could be RuleNodeTypes.ProperCase, but it is useful in more cases to already
                apply the implicit conversion to NodeTypes.segmentCase.
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Build.GrammarBuilders.Nodes.NodeRules.LowerCaseConcat(Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.concat)">
            <summary> Build a typed program node correponding to the LowerCaseConcat rule.</summary>
            <remarks>
                The return type could be RuleNodeTypes.LowerCaseConcat, but it is useful in more cases to already
                apply the implicit conversion to NodeTypes.concatCase.
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Build.GrammarBuilders.Nodes.NodeRules.UpperCaseConcat(Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.concat)">
            <summary> Build a typed program node correponding to the UpperCaseConcat rule.</summary>
            <remarks>
                The return type could be RuleNodeTypes.UpperCaseConcat, but it is useful in more cases to already
                apply the implicit conversion to NodeTypes.concatCase.
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Build.GrammarBuilders.Nodes.NodeRules.ProperCaseConcat(Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.concat)">
            <summary> Build a typed program node correponding to the ProperCaseConcat rule.</summary>
            <remarks>
                The return type could be RuleNodeTypes.ProperCaseConcat, but it is useful in more cases to already
                apply the implicit conversion to NodeTypes.concatCase.
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Build.GrammarBuilders.Nodes.NodeRules.Concat(Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.concatPrefix,Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.concatSuffix)">
            <summary> Build a typed program node correponding to the Concat rule.</summary>
            <remarks>
                The return type could be RuleNodeTypes.Concat, but it is useful in more cases to already
                apply the implicit conversion to NodeTypes.concat.
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Build.GrammarBuilders.Nodes.NodeRules.StringEquals(Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.row,Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.columnName,Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.equalsText)">
            <summary> Build a typed program node correponding to the StringEquals rule.</summary>
            <remarks>
                The return type could be RuleNodeTypes.StringEquals, but it is useful in more cases to already
                apply the implicit conversion to NodeTypes.condition.
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Build.GrammarBuilders.Nodes.NodeRules.Contains(Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.row,Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.columnName,Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.containsFindText,Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.containsCount)">
            <summary> Build a typed program node correponding to the Contains rule.</summary>
            <remarks>
                The return type could be RuleNodeTypes.Contains, but it is useful in more cases to already
                apply the implicit conversion to NodeTypes.condition.
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Build.GrammarBuilders.Nodes.NodeRules.StartsWithDigit(Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.row,Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.columnName)">
            <summary> Build a typed program node correponding to the StartsWithDigit rule.</summary>
            <remarks>
                The return type could be RuleNodeTypes.StartsWithDigit, but it is useful in more cases to already
                apply the implicit conversion to NodeTypes.condition.
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Build.GrammarBuilders.Nodes.NodeRules.EndsWithDigit(Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.row,Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.columnName)">
            <summary> Build a typed program node correponding to the EndsWithDigit rule.</summary>
            <remarks>
                The return type could be RuleNodeTypes.EndsWithDigit, but it is useful in more cases to already
                apply the implicit conversion to NodeTypes.condition.
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Build.GrammarBuilders.Nodes.NodeRules.StartsWith(Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.row,Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.columnName,Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.startsWithFindText)">
            <summary> Build a typed program node correponding to the StartsWith rule.</summary>
            <remarks>
                The return type could be RuleNodeTypes.StartsWith, but it is useful in more cases to already
                apply the implicit conversion to NodeTypes.condition.
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Build.GrammarBuilders.Nodes.NodeRules.IsBlank(Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.row,Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.columnName)">
            <summary> Build a typed program node correponding to the IsBlank rule.</summary>
            <remarks>
                The return type could be RuleNodeTypes.IsBlank, but it is useful in more cases to already
                apply the implicit conversion to NodeTypes.condition.
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Build.GrammarBuilders.Nodes.NodeRules.IsNotBlank(Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.row,Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.columnName)">
            <summary> Build a typed program node correponding to the IsNotBlank rule.</summary>
            <remarks>
                The return type could be RuleNodeTypes.IsNotBlank, but it is useful in more cases to already
                apply the implicit conversion to NodeTypes.condition.
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Build.GrammarBuilders.Nodes.NodeRules.NumberEquals(Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.row,Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.columnName,Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.numberEqualsValue)">
            <summary> Build a typed program node correponding to the NumberEquals rule.</summary>
            <remarks>
                The return type could be RuleNodeTypes.NumberEquals, but it is useful in more cases to already
                apply the implicit conversion to NodeTypes.condition.
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Build.GrammarBuilders.Nodes.NodeRules.NumberGreaterThan(Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.row,Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.columnName,Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.numberGreaterThanValue)">
            <summary> Build a typed program node correponding to the NumberGreaterThan rule.</summary>
            <remarks>
                The return type could be RuleNodeTypes.NumberGreaterThan, but it is useful in more cases to already
                apply the implicit conversion to NodeTypes.condition.
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Build.GrammarBuilders.Nodes.NodeRules.NumberLessThan(Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.row,Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.columnName,Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.numberLessThanValue)">
            <summary> Build a typed program node correponding to the NumberLessThan rule.</summary>
            <remarks>
                The return type could be RuleNodeTypes.NumberLessThan, but it is useful in more cases to already
                apply the implicit conversion to NodeTypes.condition.
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Build.GrammarBuilders.Nodes.NodeRules.IsString(Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.row,Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.columnName)">
            <summary> Build a typed program node correponding to the IsString rule.</summary>
            <remarks>
                The return type could be RuleNodeTypes.IsString, but it is useful in more cases to already
                apply the implicit conversion to NodeTypes.condition.
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Build.GrammarBuilders.Nodes.NodeRules.IsNumber(Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.row,Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.columnName)">
            <summary> Build a typed program node correponding to the IsNumber rule.</summary>
            <remarks>
                The return type could be RuleNodeTypes.IsNumber, but it is useful in more cases to already
                apply the implicit conversion to NodeTypes.condition.
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Build.GrammarBuilders.Nodes.NodeRules.IsMatch(Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.row,Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.columnName,Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.isMatchRegex)">
            <summary> Build a typed program node correponding to the IsMatch rule.</summary>
            <remarks>
                The return type could be RuleNodeTypes.IsMatch, but it is useful in more cases to already
                apply the implicit conversion to NodeTypes.condition.
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Build.GrammarBuilders.Nodes.NodeRules.ContainsMatch(Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.row,Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.columnName,Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.containsMatchRegex,Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.matchCount)">
            <summary> Build a typed program node correponding to the ContainsMatch rule.</summary>
            <remarks>
                The return type could be RuleNodeTypes.ContainsMatch, but it is useful in more cases to already
                apply the implicit conversion to NodeTypes.condition.
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Build.GrammarBuilders.Nodes.NodeRules.Or(Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.condition,Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.condition)">
            <summary> Build a typed program node correponding to the Or rule.</summary>
            <remarks>
                The return type could be RuleNodeTypes.Or, but it is useful in more cases to already
                apply the implicit conversion to NodeTypes.@or.
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Build.GrammarBuilders.Nodes.NodeRules.Null">
            <summary> Build a typed program node correponding to the Null rule.</summary>
            <remarks>
                The return type could be RuleNodeTypes.Null, but it is useful in more cases to already
                apply the implicit conversion to NodeTypes.inull.
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Build.GrammarBuilders.Nodes.NodeRules.FormatNumber(Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.number,Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.numberFormatDesc)">
            <summary> Build a typed program node correponding to the FormatNumber rule.</summary>
            <remarks>
                The return type could be RuleNodeTypes.FormatNumber, but it is useful in more cases to already
                apply the implicit conversion to NodeTypes.formatNumber.
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Build.GrammarBuilders.Nodes.NodeRules.DateTimePart(Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.idate,Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.dateTimePartKind)">
            <summary> Build a typed program node correponding to the DateTimePart rule.</summary>
            <remarks>
                The return type could be RuleNodeTypes.DateTimePart, but it is useful in more cases to already
                apply the implicit conversion to NodeTypes.numberOther.
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Build.GrammarBuilders.Nodes.NodeRules.TimePart(Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.itime,Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.timePartKind)">
            <summary> Build a typed program node correponding to the TimePart rule.</summary>
            <remarks>
                The return type could be RuleNodeTypes.TimePart, but it is useful in more cases to already
                apply the implicit conversion to NodeTypes.numberOther.
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Build.GrammarBuilders.Nodes.NodeRules.RoundNumber(Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.numberSource,Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.numberRoundDesc)">
            <summary> Build a typed program node correponding to the RoundNumber rule.</summary>
            <remarks>
                The return type could be RuleNodeTypes.RoundNumber, but it is useful in more cases to already
                apply the implicit conversion to NodeTypes.numberOther.
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Build.GrammarBuilders.Nodes.NodeRules.Length(Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.fromStr)">
            <summary> Build a typed program node correponding to the Length rule.</summary>
            <remarks>
                The return type could be RuleNodeTypes.Length, but it is useful in more cases to already
                apply the implicit conversion to NodeTypes.numberOther.
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Build.GrammarBuilders.Nodes.NodeRules.ParseNumber(Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.parseSubject,Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.locale)">
            <summary> Build a typed program node correponding to the ParseNumber rule.</summary>
            <remarks>
                The return type could be RuleNodeTypes.ParseNumber, but it is useful in more cases to already
                apply the implicit conversion to NodeTypes.numberSource.
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Build.GrammarBuilders.Nodes.NodeRules.Add(Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.arithmeticSource,Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.arithmeticSource)">
            <summary> Build a typed program node correponding to the Add rule.</summary>
            <remarks>
                The return type could be RuleNodeTypes.Add, but it is useful in more cases to already
                apply the implicit conversion to NodeTypes.arithmeticPair.
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Build.GrammarBuilders.Nodes.NodeRules.Subtract(Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.arithmeticSource,Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.arithmeticSource)">
            <summary> Build a typed program node correponding to the Subtract rule.</summary>
            <remarks>
                The return type could be RuleNodeTypes.Subtract, but it is useful in more cases to already
                apply the implicit conversion to NodeTypes.arithmeticPair.
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Build.GrammarBuilders.Nodes.NodeRules.Multiply(Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.arithmeticSource,Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.arithmeticSource)">
            <summary> Build a typed program node correponding to the Multiply rule.</summary>
            <remarks>
                The return type could be RuleNodeTypes.Multiply, but it is useful in more cases to already
                apply the implicit conversion to NodeTypes.arithmeticPair.
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Build.GrammarBuilders.Nodes.NodeRules.Divide(Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.arithmeticSource,Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.arithmeticSource)">
            <summary> Build a typed program node correponding to the Divide rule.</summary>
            <remarks>
                The return type could be RuleNodeTypes.Divide, but it is useful in more cases to already
                apply the implicit conversion to NodeTypes.arithmeticPair.
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Build.GrammarBuilders.Nodes.NodeRules.Sum(Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.fromNumbers)">
            <summary> Build a typed program node correponding to the Sum rule.</summary>
            <remarks>
                The return type could be RuleNodeTypes.Sum, but it is useful in more cases to already
                apply the implicit conversion to NodeTypes.arithmeticAggregate.
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Build.GrammarBuilders.Nodes.NodeRules.Product(Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.fromNumbers)">
            <summary> Build a typed program node correponding to the Product rule.</summary>
            <remarks>
                The return type could be RuleNodeTypes.Product, but it is useful in more cases to already
                apply the implicit conversion to NodeTypes.arithmeticAggregate.
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Build.GrammarBuilders.Nodes.NodeRules.Average(Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.fromNumbers)">
            <summary> Build a typed program node correponding to the Average rule.</summary>
            <remarks>
                The return type could be RuleNodeTypes.Average, but it is useful in more cases to already
                apply the implicit conversion to NodeTypes.arithmeticAggregate.
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Build.GrammarBuilders.Nodes.NodeRules.AddRightConstant(Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.arithmeticSource,Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.constNum)">
            <summary> Build a typed program node correponding to the AddRightConstant rule.</summary>
            <remarks>
                The return type could be RuleNodeTypes.AddRightConstant, but it is useful in more cases to already
                apply the implicit conversion to NodeTypes.arithmeticRightConstant.
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Build.GrammarBuilders.Nodes.NodeRules.SubtractRightConstant(Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.arithmeticSource,Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.constNum)">
            <summary> Build a typed program node correponding to the SubtractRightConstant rule.</summary>
            <remarks>
                The return type could be RuleNodeTypes.SubtractRightConstant, but it is useful in more cases to already
                apply the implicit conversion to NodeTypes.arithmeticRightConstant.
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Build.GrammarBuilders.Nodes.NodeRules.MultiplyRightConstant(Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.arithmeticSource,Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.constNum)">
            <summary> Build a typed program node correponding to the MultiplyRightConstant rule.</summary>
            <remarks>
                The return type could be RuleNodeTypes.MultiplyRightConstant, but it is useful in more cases to already
                apply the implicit conversion to NodeTypes.arithmeticRightConstant.
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Build.GrammarBuilders.Nodes.NodeRules.DivideRightConstant(Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.arithmeticSource,Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.constNum)">
            <summary> Build a typed program node correponding to the DivideRightConstant rule.</summary>
            <remarks>
                The return type could be RuleNodeTypes.DivideRightConstant, but it is useful in more cases to already
                apply the implicit conversion to NodeTypes.arithmeticRightConstant.
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Build.GrammarBuilders.Nodes.NodeRules.SubtractLeftConstant(Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.constNum,Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.arithmeticSource)">
            <summary> Build a typed program node correponding to the SubtractLeftConstant rule.</summary>
            <remarks>
                The return type could be RuleNodeTypes.SubtractLeftConstant, but it is useful in more cases to already
                apply the implicit conversion to NodeTypes.arithmeticLeftConstant.
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Build.GrammarBuilders.Nodes.NodeRules.DivideLeftConstant(Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.constNum,Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.arithmeticSource)">
            <summary> Build a typed program node correponding to the DivideLeftConstant rule.</summary>
            <remarks>
                The return type could be RuleNodeTypes.DivideLeftConstant, but it is useful in more cases to already
                apply the implicit conversion to NodeTypes.arithmeticLeftConstant.
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Build.GrammarBuilders.Nodes.NodeRules.RowNumberLinearTransform(Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.fromRowNumber,Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.rowNumberLinearTransformDesc)">
            <summary> Build a typed program node correponding to the RowNumberLinearTransform rule.</summary>
            <remarks>
                The return type could be RuleNodeTypes.RowNumberLinearTransform, but it is useful in more cases to already
                apply the implicit conversion to NodeTypes.rowNumberTransform.
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Build.GrammarBuilders.Nodes.NodeRules.FormatDateTime(Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.date,Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.dateTimeFormatDesc)">
            <summary> Build a typed program node correponding to the FormatDateTime rule.</summary>
            <remarks>
                The return type could be RuleNodeTypes.FormatDateTime, but it is useful in more cases to already
                apply the implicit conversion to NodeTypes.formatDateTime.
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Build.GrammarBuilders.Nodes.NodeRules.RoundDateTime(Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.idate,Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.dateTimeRoundDesc)">
            <summary> Build a typed program node correponding to the RoundDateTime rule.</summary>
            <remarks>
                The return type could be RuleNodeTypes.RoundDateTime, but it is useful in more cases to already
                apply the implicit conversion to NodeTypes.date.
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Build.GrammarBuilders.Nodes.NodeRules.ParseDateTime(Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.parseSubject,Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.dateTimeParseDesc)">
            <summary> Build a typed program node correponding to the ParseDateTime rule.</summary>
            <remarks>
                The return type could be RuleNodeTypes.ParseDateTime, but it is useful in more cases to already
                apply the implicit conversion to NodeTypes.idate.
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Build.GrammarBuilders.Nodes.NodeRules.SlicePrefixAbs(Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.x,Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.slicePrefixAbsPos)">
            <summary> Build a typed program node correponding to the SlicePrefixAbs rule.</summary>
            <remarks>
                The return type could be RuleNodeTypes.SlicePrefixAbs, but it is useful in more cases to already
                apply the implicit conversion to NodeTypes.substring.
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Build.GrammarBuilders.Nodes.NodeRules.SlicePrefix(Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.x,Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.pos)">
            <summary> Build a typed program node correponding to the SlicePrefix rule.</summary>
            <remarks>
                The return type could be RuleNodeTypes.SlicePrefix, but it is useful in more cases to already
                apply the implicit conversion to NodeTypes.substring.
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Build.GrammarBuilders.Nodes.NodeRules.SliceSuffix(Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.x,Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.pos)">
            <summary> Build a typed program node correponding to the SliceSuffix rule.</summary>
            <remarks>
                The return type could be RuleNodeTypes.SliceSuffix, but it is useful in more cases to already
                apply the implicit conversion to NodeTypes.substring.
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Build.GrammarBuilders.Nodes.NodeRules.MatchFull(Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.x,Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.matchDesc,Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.matchInstance)">
            <summary> Build a typed program node correponding to the MatchFull rule.</summary>
            <remarks>
                The return type could be RuleNodeTypes.MatchFull, but it is useful in more cases to already
                apply the implicit conversion to NodeTypes.substring.
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Build.GrammarBuilders.Nodes.NodeRules.SliceBetween(Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.x,Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.sliceBetweenStartText,Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.sliceBetweenEndText)">
            <summary> Build a typed program node correponding to the SliceBetween rule.</summary>
            <remarks>
                The return type could be RuleNodeTypes.SliceBetween, but it is useful in more cases to already
                apply the implicit conversion to NodeTypes.substring.
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Build.GrammarBuilders.Nodes.NodeRules.TrimSplit(Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.split)">
            <summary> Build a typed program node correponding to the TrimSplit rule.</summary>
            <remarks>
                The return type could be RuleNodeTypes.TrimSplit, but it is useful in more cases to already
                apply the implicit conversion to NodeTypes.splitTrim.
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Build.GrammarBuilders.Nodes.NodeRules.TrimFullSplit(Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.split)">
            <summary> Build a typed program node correponding to the TrimFullSplit rule.</summary>
            <remarks>
                The return type could be RuleNodeTypes.TrimFullSplit, but it is useful in more cases to already
                apply the implicit conversion to NodeTypes.splitTrim.
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Build.GrammarBuilders.Nodes.NodeRules.Split(Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.x,Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.splitDelimiter,Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.splitInstance)">
            <summary> Build a typed program node correponding to the Split rule.</summary>
            <remarks>
                The return type could be RuleNodeTypes.Split, but it is useful in more cases to already
                apply the implicit conversion to NodeTypes.split.
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Build.GrammarBuilders.Nodes.NodeRules.TrimSlice(Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.slice)">
            <summary> Build a typed program node correponding to the TrimSlice rule.</summary>
            <remarks>
                The return type could be RuleNodeTypes.TrimSlice, but it is useful in more cases to already
                apply the implicit conversion to NodeTypes.sliceTrim.
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Build.GrammarBuilders.Nodes.NodeRules.TrimFullSlice(Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.slice)">
            <summary> Build a typed program node correponding to the TrimFullSlice rule.</summary>
            <remarks>
                The return type could be RuleNodeTypes.TrimFullSlice, but it is useful in more cases to already
                apply the implicit conversion to NodeTypes.sliceTrim.
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Build.GrammarBuilders.Nodes.NodeRules.Slice(Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.x,Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.pos,Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.pos)">
            <summary> Build a typed program node correponding to the Slice rule.</summary>
            <remarks>
                The return type could be RuleNodeTypes.Slice, but it is useful in more cases to already
                apply the implicit conversion to NodeTypes.slice.
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Build.GrammarBuilders.Nodes.NodeRules.Find(Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.x,Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.findDelimiter,Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.findInstance,Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.findOffset)">
            <summary> Build a typed program node correponding to the Find rule.</summary>
            <remarks>
                The return type could be RuleNodeTypes.Find, but it is useful in more cases to already
                apply the implicit conversion to NodeTypes.pos.
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Build.GrammarBuilders.Nodes.NodeRules.Abs(Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.x,Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.absPos)">
            <summary> Build a typed program node correponding to the Abs rule.</summary>
            <remarks>
                The return type could be RuleNodeTypes.Abs, but it is useful in more cases to already
                apply the implicit conversion to NodeTypes.pos.
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Build.GrammarBuilders.Nodes.NodeRules.Match(Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.x,Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.matchDesc,Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.matchInstance)">
            <summary> Build a typed program node correponding to the Match rule.</summary>
            <remarks>
                The return type could be RuleNodeTypes.Match, but it is useful in more cases to already
                apply the implicit conversion to NodeTypes.pos.
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Build.GrammarBuilders.Nodes.NodeRules.MatchEnd(Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.x,Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.matchDesc,Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.matchInstance)">
            <summary> Build a typed program node correponding to the MatchEnd rule.</summary>
            <remarks>
                The return type could be RuleNodeTypes.MatchEnd, but it is useful in more cases to already
                apply the implicit conversion to NodeTypes.pos.
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Build.GrammarBuilders.Nodes.NodeRules.FromLookup(Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.lookupTables,Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.lookupTableName,Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.fromLookupKey,Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.lookupKeyColumnName,Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.lookupValueColumnName)">
            <summary> Build a typed program node correponding to the FromLookup rule.</summary>
            <remarks>
                The return type could be RuleNodeTypes.FromLookup, but it is useful in more cases to already
                apply the implicit conversion to NodeTypes.fromLookup.
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Build.GrammarBuilders.Nodes.NodeRules.FromIntrinsicLookup(Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.intrinsicLookupTables,Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.lookupTableName,Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.fromLookupKey,Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.lookupKeyColumnName,Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.lookupValueColumnName)">
            <summary> Build a typed program node correponding to the FromIntrinsicLookup rule.</summary>
            <remarks>
                The return type could be RuleNodeTypes.FromIntrinsicLookup, but it is useful in more cases to already
                apply the implicit conversion to NodeTypes.fromLookup.
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Build.GrammarBuilders.Nodes.NodeRules.TrimFull(Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.fromStr)">
            <summary> Build a typed program node correponding to the TrimFull rule.</summary>
            <remarks>
                The return type could be RuleNodeTypes.TrimFull, but it is useful in more cases to already
                apply the implicit conversion to NodeTypes.fromStrTrim.
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Build.GrammarBuilders.Nodes.NodeRules.Trim(Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.fromStr)">
            <summary> Build a typed program node correponding to the Trim rule.</summary>
            <remarks>
                The return type could be RuleNodeTypes.Trim, but it is useful in more cases to already
                apply the implicit conversion to NodeTypes.fromStrTrim.
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Build.GrammarBuilders.Nodes.NodeRules.FromStr(Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.row,Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.columnName)">
            <summary> Build a typed program node correponding to the FromStr rule.</summary>
            <remarks>
                The return type could be RuleNodeTypes.FromStr, but it is useful in more cases to already
                apply the implicit conversion to NodeTypes.fromStr.
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Build.GrammarBuilders.Nodes.NodeRules.FromNumberStr(Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.row,Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.columnName)">
            <summary> Build a typed program node correponding to the FromNumberStr rule.</summary>
            <remarks>
                The return type could be RuleNodeTypes.FromNumberStr, but it is useful in more cases to already
                apply the implicit conversion to NodeTypes.fromNumberStr.
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Build.GrammarBuilders.Nodes.NodeRules.FromNumber(Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.row,Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.columnName)">
            <summary> Build a typed program node correponding to the FromNumber rule.</summary>
            <remarks>
                The return type could be RuleNodeTypes.FromNumber, but it is useful in more cases to already
                apply the implicit conversion to NodeTypes.fromNumber.
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Build.GrammarBuilders.Nodes.NodeRules.FromNumberCoalesced(Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.row,Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.columnName)">
            <summary> Build a typed program node correponding to the FromNumberCoalesced rule.</summary>
            <remarks>
                The return type could be RuleNodeTypes.FromNumberCoalesced, but it is useful in more cases to already
                apply the implicit conversion to NodeTypes.fromNumberCoalesced.
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Build.GrammarBuilders.Nodes.NodeRules.FromRowNumber(Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.row)">
            <summary> Build a typed program node correponding to the FromRowNumber rule.</summary>
            <remarks>
                The return type could be RuleNodeTypes.FromRowNumber, but it is useful in more cases to already
                apply the implicit conversion to NodeTypes.fromRowNumber.
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Build.GrammarBuilders.Nodes.NodeRules.FromNumbers(Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.row,Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.columnNames)">
            <summary> Build a typed program node correponding to the FromNumbers rule.</summary>
            <remarks>
                The return type could be RuleNodeTypes.FromNumbers, but it is useful in more cases to already
                apply the implicit conversion to NodeTypes.fromNumbers.
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Build.GrammarBuilders.Nodes.NodeRules.FromDateTime(Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.row,Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.columnName)">
            <summary> Build a typed program node correponding to the FromDateTime rule.</summary>
            <remarks>
                The return type could be RuleNodeTypes.FromDateTime, but it is useful in more cases to already
                apply the implicit conversion to NodeTypes.fromDateTime.
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Build.GrammarBuilders.Nodes.NodeRules.FromDateTimePart(Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.row,Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.columnName,Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.fromDateTimePartKind)">
            <summary> Build a typed program node correponding to the FromDateTimePart rule.</summary>
            <remarks>
                The return type could be RuleNodeTypes.FromDateTimePart, but it is useful in more cases to already
                apply the implicit conversion to NodeTypes.fromDateTimePart.
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Build.GrammarBuilders.Nodes.NodeRules.FromTime(Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.row,Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.columnName)">
            <summary> Build a typed program node correponding to the FromTime rule.</summary>
            <remarks>
                The return type could be RuleNodeTypes.FromTime, but it is useful in more cases to already
                apply the implicit conversion to NodeTypes.fromTime.
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Build.GrammarBuilders.Nodes.NodeRules.Str(Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.constStr)">
            <summary> Build a typed program node correponding to the Str rule.</summary>
            <remarks>
                The return type could be RuleNodeTypes.Str, but it is useful in more cases to already
                apply the implicit conversion to NodeTypes.constString.
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Build.GrammarBuilders.Nodes.NodeRules.Number(Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.constNum)">
            <summary> Build a typed program node correponding to the Number rule.</summary>
            <remarks>
                The return type could be RuleNodeTypes.Number, but it is useful in more cases to already
                apply the implicit conversion to NodeTypes.constNumber.
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Build.GrammarBuilders.Nodes.NodeRules.Date(Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.constDt)">
            <summary> Build a typed program node correponding to the Date rule.</summary>
            <remarks>
                The return type could be RuleNodeTypes.Date, but it is useful in more cases to already
                apply the implicit conversion to NodeTypes.constDate.
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Build.GrammarBuilders.Nodes.NodeRules.LetX(Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.fromStrTrim,Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.substring)">
            <summary> Build a typed program node correponding to the LetX rule.</summary>
            <remarks>
                The return type could be RuleNodeTypes.LetX, but it is useful in more cases to already
                apply the implicit conversion to NodeTypes.letSubstring.
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Build.GrammarBuilders.Nodes.NodeUnnamedConversionRules.result_output(Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.output)">
            <summary> Build a typed program node correponding to the ~convert_result_output rule.</summary>
            <remarks>
                The return type could be UnnamedConversionNodeTypes.result_output, but it is useful in more cases to already
                apply the implicit conversion to NodeTypes.result.
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Build.GrammarBuilders.Nodes.NodeUnnamedConversionRules.result_inull(Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.inull)">
            <summary> Build a typed program node correponding to the ~convert_result_inull rule.</summary>
            <remarks>
                The return type could be UnnamedConversionNodeTypes.result_inull, but it is useful in more cases to already
                apply the implicit conversion to NodeTypes.result.
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Build.GrammarBuilders.Nodes.NodeUnnamedConversionRules.outNumber_number(Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.number)">
            <summary> Build a typed program node correponding to the ~convert_outNumber_number rule.</summary>
            <remarks>
                The return type could be UnnamedConversionNodeTypes.outNumber_number, but it is useful in more cases to already
                apply the implicit conversion to NodeTypes.outNumber.
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Build.GrammarBuilders.Nodes.NodeUnnamedConversionRules.outNumber_constNumber(Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.constNumber)">
            <summary> Build a typed program node correponding to the ~convert_outNumber_constNumber rule.</summary>
            <remarks>
                The return type could be UnnamedConversionNodeTypes.outNumber_constNumber, but it is useful in more cases to already
                apply the implicit conversion to NodeTypes.outNumber.
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Build.GrammarBuilders.Nodes.NodeUnnamedConversionRules.outDate_date(Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.date)">
            <summary> Build a typed program node correponding to the ~convert_outDate_date rule.</summary>
            <remarks>
                The return type could be UnnamedConversionNodeTypes.outDate_date, but it is useful in more cases to already
                apply the implicit conversion to NodeTypes.outDate.
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Build.GrammarBuilders.Nodes.NodeUnnamedConversionRules.outDate_constDate(Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.constDate)">
            <summary> Build a typed program node correponding to the ~convert_outDate_constDate rule.</summary>
            <remarks>
                The return type could be UnnamedConversionNodeTypes.outDate_constDate, but it is useful in more cases to already
                apply the implicit conversion to NodeTypes.outDate.
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Build.GrammarBuilders.Nodes.NodeUnnamedConversionRules.outStr_outStr1(Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.outStr1)">
            <summary> Build a typed program node correponding to the ~convert_outStr_outStr1 rule.</summary>
            <remarks>
                The return type could be UnnamedConversionNodeTypes.outStr_outStr1, but it is useful in more cases to already
                apply the implicit conversion to NodeTypes.outStr.
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Build.GrammarBuilders.Nodes.NodeUnnamedConversionRules.outStr1_segmentCase(Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.segmentCase)">
            <summary> Build a typed program node correponding to the ~convert_outStr1_segmentCase rule.</summary>
            <remarks>
                The return type could be UnnamedConversionNodeTypes.outStr1_segmentCase, but it is useful in more cases to already
                apply the implicit conversion to NodeTypes.outStr1.
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Build.GrammarBuilders.Nodes.NodeUnnamedConversionRules.outStr1_formatted(Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.formatted)">
            <summary> Build a typed program node correponding to the ~convert_outStr1_formatted rule.</summary>
            <remarks>
                The return type could be UnnamedConversionNodeTypes.outStr1_formatted, but it is useful in more cases to already
                apply the implicit conversion to NodeTypes.outStr1.
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Build.GrammarBuilders.Nodes.NodeUnnamedConversionRules.outStr1_concatEntry(Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.concatEntry)">
            <summary> Build a typed program node correponding to the ~convert_outStr1_concatEntry rule.</summary>
            <remarks>
                The return type could be UnnamedConversionNodeTypes.outStr1_concatEntry, but it is useful in more cases to already
                apply the implicit conversion to NodeTypes.outStr1.
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Build.GrammarBuilders.Nodes.NodeUnnamedConversionRules.outStr1_constString(Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.constString)">
            <summary> Build a typed program node correponding to the ~convert_outStr1_constString rule.</summary>
            <remarks>
                The return type could be UnnamedConversionNodeTypes.outStr1_constString, but it is useful in more cases to already
                apply the implicit conversion to NodeTypes.outStr1.
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Build.GrammarBuilders.Nodes.NodeUnnamedConversionRules.segmentCase_segment(Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.segment)">
            <summary> Build a typed program node correponding to the ~convert_segmentCase_segment rule.</summary>
            <remarks>
                The return type could be UnnamedConversionNodeTypes.segmentCase_segment, but it is useful in more cases to already
                apply the implicit conversion to NodeTypes.segmentCase.
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Build.GrammarBuilders.Nodes.NodeUnnamedConversionRules.segment_fromStrTrim(Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.fromStrTrim)">
            <summary> Build a typed program node correponding to the ~convert_segment_fromStrTrim rule.</summary>
            <remarks>
                The return type could be UnnamedConversionNodeTypes.segment_fromStrTrim, but it is useful in more cases to already
                apply the implicit conversion to NodeTypes.segment.
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Build.GrammarBuilders.Nodes.NodeUnnamedConversionRules.segment_fromLookup(Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.fromLookup)">
            <summary> Build a typed program node correponding to the ~convert_segment_fromLookup rule.</summary>
            <remarks>
                The return type could be UnnamedConversionNodeTypes.segment_fromLookup, but it is useful in more cases to already
                apply the implicit conversion to NodeTypes.segment.
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Build.GrammarBuilders.Nodes.NodeUnnamedConversionRules.segment_letSubstring(Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.letSubstring)">
            <summary> Build a typed program node correponding to the ~convert_segment_letSubstring rule.</summary>
            <remarks>
                The return type could be UnnamedConversionNodeTypes.segment_letSubstring, but it is useful in more cases to already
                apply the implicit conversion to NodeTypes.segment.
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Build.GrammarBuilders.Nodes.NodeUnnamedConversionRules.formatted_formatNumber(Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.formatNumber)">
            <summary> Build a typed program node correponding to the ~convert_formatted_formatNumber rule.</summary>
            <remarks>
                The return type could be UnnamedConversionNodeTypes.formatted_formatNumber, but it is useful in more cases to already
                apply the implicit conversion to NodeTypes.formatted.
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Build.GrammarBuilders.Nodes.NodeUnnamedConversionRules.formatted_formatDateTime(Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.formatDateTime)">
            <summary> Build a typed program node correponding to the ~convert_formatted_formatDateTime rule.</summary>
            <remarks>
                The return type could be UnnamedConversionNodeTypes.formatted_formatDateTime, but it is useful in more cases to already
                apply the implicit conversion to NodeTypes.formatted.
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Build.GrammarBuilders.Nodes.NodeUnnamedConversionRules.concatEntry_concatCase(Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.concatCase)">
            <summary> Build a typed program node correponding to the ~convert_concatEntry_concatCase rule.</summary>
            <remarks>
                The return type could be UnnamedConversionNodeTypes.concatEntry_concatCase, but it is useful in more cases to already
                apply the implicit conversion to NodeTypes.concatEntry.
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Build.GrammarBuilders.Nodes.NodeUnnamedConversionRules.concatEntry_constString(Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.constString)">
            <summary> Build a typed program node correponding to the ~convert_concatEntry_constString rule.</summary>
            <remarks>
                The return type could be UnnamedConversionNodeTypes.concatEntry_constString, but it is useful in more cases to already
                apply the implicit conversion to NodeTypes.concatEntry.
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Build.GrammarBuilders.Nodes.NodeUnnamedConversionRules.concatCase_concat(Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.concat)">
            <summary> Build a typed program node correponding to the ~convert_concatCase_concat rule.</summary>
            <remarks>
                The return type could be UnnamedConversionNodeTypes.concatCase_concat, but it is useful in more cases to already
                apply the implicit conversion to NodeTypes.concatCase.
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Build.GrammarBuilders.Nodes.NodeUnnamedConversionRules.concatPrefix_concatSegment(Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.concatSegment)">
            <summary> Build a typed program node correponding to the ~convert_concatPrefix_concatSegment rule.</summary>
            <remarks>
                The return type could be UnnamedConversionNodeTypes.concatPrefix_concatSegment, but it is useful in more cases to already
                apply the implicit conversion to NodeTypes.concatPrefix.
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Build.GrammarBuilders.Nodes.NodeUnnamedConversionRules.concatPrefix_formatted(Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.formatted)">
            <summary> Build a typed program node correponding to the ~convert_concatPrefix_formatted rule.</summary>
            <remarks>
                The return type could be UnnamedConversionNodeTypes.concatPrefix_formatted, but it is useful in more cases to already
                apply the implicit conversion to NodeTypes.concatPrefix.
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Build.GrammarBuilders.Nodes.NodeUnnamedConversionRules.concatPrefix_constString(Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.constString)">
            <summary> Build a typed program node correponding to the ~convert_concatPrefix_constString rule.</summary>
            <remarks>
                The return type could be UnnamedConversionNodeTypes.concatPrefix_constString, but it is useful in more cases to already
                apply the implicit conversion to NodeTypes.concatPrefix.
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Build.GrammarBuilders.Nodes.NodeUnnamedConversionRules.concatSegment_segment(Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.segment)">
            <summary> Build a typed program node correponding to the ~convert_concatSegment_segment rule.</summary>
            <remarks>
                The return type could be UnnamedConversionNodeTypes.concatSegment_segment, but it is useful in more cases to already
                apply the implicit conversion to NodeTypes.concatSegment.
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Build.GrammarBuilders.Nodes.NodeUnnamedConversionRules.concatSegment_segmentCase(Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.segmentCase)">
            <summary> Build a typed program node correponding to the ~convert_concatSegment_segmentCase rule.</summary>
            <remarks>
                The return type could be UnnamedConversionNodeTypes.concatSegment_segmentCase, but it is useful in more cases to already
                apply the implicit conversion to NodeTypes.concatSegment.
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Build.GrammarBuilders.Nodes.NodeUnnamedConversionRules.concatSuffix_concatPrefix(Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.concatPrefix)">
            <summary> Build a typed program node correponding to the ~convert_concatSuffix_concatPrefix rule.</summary>
            <remarks>
                The return type could be UnnamedConversionNodeTypes.concatSuffix_concatPrefix, but it is useful in more cases to already
                apply the implicit conversion to NodeTypes.concatSuffix.
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Build.GrammarBuilders.Nodes.NodeUnnamedConversionRules.concatSuffix_concat(Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.concat)">
            <summary> Build a typed program node correponding to the ~convert_concatSuffix_concat rule.</summary>
            <remarks>
                The return type could be UnnamedConversionNodeTypes.concatSuffix_concat, but it is useful in more cases to already
                apply the implicit conversion to NodeTypes.concatSuffix.
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Build.GrammarBuilders.Nodes.NodeUnnamedConversionRules.condition_or(Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.or)">
            <summary> Build a typed program node correponding to the ~convert_condition_or rule.</summary>
            <remarks>
                The return type could be UnnamedConversionNodeTypes.condition_or, but it is useful in more cases to already
                apply the implicit conversion to NodeTypes.condition.
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Build.GrammarBuilders.Nodes.NodeUnnamedConversionRules.number_numberNormalPriority(Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.numberNormalPriority)">
            <summary> Build a typed program node correponding to the ~convert_number_numberNormalPriority rule.</summary>
            <remarks>
                The return type could be UnnamedConversionNodeTypes.number_numberNormalPriority, but it is useful in more cases to already
                apply the implicit conversion to NodeTypes.number.
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Build.GrammarBuilders.Nodes.NodeUnnamedConversionRules.number_numberSourcePriority(Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.numberSourcePriority)">
            <summary> Build a typed program node correponding to the ~convert_number_numberSourcePriority rule.</summary>
            <remarks>
                The return type could be UnnamedConversionNodeTypes.number_numberSourcePriority, but it is useful in more cases to already
                apply the implicit conversion to NodeTypes.number.
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Build.GrammarBuilders.Nodes.NodeUnnamedConversionRules.numberNormalPriority_arithmetic(Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.arithmetic)">
            <summary> Build a typed program node correponding to the ~convert_numberNormalPriority_arithmetic rule.</summary>
            <remarks>
                The return type could be UnnamedConversionNodeTypes.numberNormalPriority_arithmetic, but it is useful in more cases to already
                apply the implicit conversion to NodeTypes.numberNormalPriority.
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Build.GrammarBuilders.Nodes.NodeUnnamedConversionRules.numberNormalPriority_numberSource(Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.numberSource)">
            <summary> Build a typed program node correponding to the ~convert_numberNormalPriority_numberSource rule.</summary>
            <remarks>
                The return type could be UnnamedConversionNodeTypes.numberNormalPriority_numberSource, but it is useful in more cases to already
                apply the implicit conversion to NodeTypes.numberNormalPriority.
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Build.GrammarBuilders.Nodes.NodeUnnamedConversionRules.numberNormalPriority_numberOther(Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.numberOther)">
            <summary> Build a typed program node correponding to the ~convert_numberNormalPriority_numberOther rule.</summary>
            <remarks>
                The return type could be UnnamedConversionNodeTypes.numberNormalPriority_numberOther, but it is useful in more cases to already
                apply the implicit conversion to NodeTypes.numberNormalPriority.
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Build.GrammarBuilders.Nodes.NodeUnnamedConversionRules.numberSourcePriority_numberSource(Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.numberSource)">
            <summary> Build a typed program node correponding to the ~convert_numberSourcePriority_numberSource rule.</summary>
            <remarks>
                The return type could be UnnamedConversionNodeTypes.numberSourcePriority_numberSource, but it is useful in more cases to already
                apply the implicit conversion to NodeTypes.numberSourcePriority.
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Build.GrammarBuilders.Nodes.NodeUnnamedConversionRules.numberSourcePriority_arithmetic(Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.arithmetic)">
            <summary> Build a typed program node correponding to the ~convert_numberSourcePriority_arithmetic rule.</summary>
            <remarks>
                The return type could be UnnamedConversionNodeTypes.numberSourcePriority_arithmetic, but it is useful in more cases to already
                apply the implicit conversion to NodeTypes.numberSourcePriority.
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Build.GrammarBuilders.Nodes.NodeUnnamedConversionRules.numberSourcePriority_numberOther(Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.numberOther)">
            <summary> Build a typed program node correponding to the ~convert_numberSourcePriority_numberOther rule.</summary>
            <remarks>
                The return type could be UnnamedConversionNodeTypes.numberSourcePriority_numberOther, but it is useful in more cases to already
                apply the implicit conversion to NodeTypes.numberSourcePriority.
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Build.GrammarBuilders.Nodes.NodeUnnamedConversionRules.numberOther_rowNumberTransform(Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.rowNumberTransform)">
            <summary> Build a typed program node correponding to the ~convert_numberOther_rowNumberTransform rule.</summary>
            <remarks>
                The return type could be UnnamedConversionNodeTypes.numberOther_rowNumberTransform, but it is useful in more cases to already
                apply the implicit conversion to NodeTypes.numberOther.
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Build.GrammarBuilders.Nodes.NodeUnnamedConversionRules.numberSource_fromNumber(Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.fromNumber)">
            <summary> Build a typed program node correponding to the ~convert_numberSource_fromNumber rule.</summary>
            <remarks>
                The return type could be UnnamedConversionNodeTypes.numberSource_fromNumber, but it is useful in more cases to already
                apply the implicit conversion to NodeTypes.numberSource.
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Build.GrammarBuilders.Nodes.NodeUnnamedConversionRules.arithmeticSource_fromNumberCoalesced(Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.fromNumberCoalesced)">
            <summary> Build a typed program node correponding to the ~convert_arithmeticSource_fromNumberCoalesced rule.</summary>
            <remarks>
                The return type could be UnnamedConversionNodeTypes.arithmeticSource_fromNumberCoalesced, but it is useful in more cases to already
                apply the implicit conversion to NodeTypes.arithmeticSource.
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Build.GrammarBuilders.Nodes.NodeUnnamedConversionRules.arithmeticSource_numberSource(Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.numberSource)">
            <summary> Build a typed program node correponding to the ~convert_arithmeticSource_numberSource rule.</summary>
            <remarks>
                The return type could be UnnamedConversionNodeTypes.arithmeticSource_numberSource, but it is useful in more cases to already
                apply the implicit conversion to NodeTypes.arithmeticSource.
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Build.GrammarBuilders.Nodes.NodeUnnamedConversionRules.arithmetic_arithmeticPair(Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.arithmeticPair)">
            <summary> Build a typed program node correponding to the ~convert_arithmetic_arithmeticPair rule.</summary>
            <remarks>
                The return type could be UnnamedConversionNodeTypes.arithmetic_arithmeticPair, but it is useful in more cases to already
                apply the implicit conversion to NodeTypes.arithmetic.
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Build.GrammarBuilders.Nodes.NodeUnnamedConversionRules.arithmetic_arithmeticAggregate(Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.arithmeticAggregate)">
            <summary> Build a typed program node correponding to the ~convert_arithmetic_arithmeticAggregate rule.</summary>
            <remarks>
                The return type could be UnnamedConversionNodeTypes.arithmetic_arithmeticAggregate, but it is useful in more cases to already
                apply the implicit conversion to NodeTypes.arithmetic.
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Build.GrammarBuilders.Nodes.NodeUnnamedConversionRules.arithmetic_arithmeticRightConstant(Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.arithmeticRightConstant)">
            <summary> Build a typed program node correponding to the ~convert_arithmetic_arithmeticRightConstant rule.</summary>
            <remarks>
                The return type could be UnnamedConversionNodeTypes.arithmetic_arithmeticRightConstant, but it is useful in more cases to already
                apply the implicit conversion to NodeTypes.arithmetic.
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Build.GrammarBuilders.Nodes.NodeUnnamedConversionRules.arithmetic_arithmeticLeftConstant(Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.arithmeticLeftConstant)">
            <summary> Build a typed program node correponding to the ~convert_arithmetic_arithmeticLeftConstant rule.</summary>
            <remarks>
                The return type could be UnnamedConversionNodeTypes.arithmetic_arithmeticLeftConstant, but it is useful in more cases to already
                apply the implicit conversion to NodeTypes.arithmetic.
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Build.GrammarBuilders.Nodes.NodeUnnamedConversionRules.rowNumberTransform_fromRowNumber(Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.fromRowNumber)">
            <summary> Build a typed program node correponding to the ~convert_rowNumberTransform_fromRowNumber rule.</summary>
            <remarks>
                The return type could be UnnamedConversionNodeTypes.rowNumberTransform_fromRowNumber, but it is useful in more cases to already
                apply the implicit conversion to NodeTypes.rowNumberTransform.
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Build.GrammarBuilders.Nodes.NodeUnnamedConversionRules.date_idate(Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.idate)">
            <summary> Build a typed program node correponding to the ~convert_date_idate rule.</summary>
            <remarks>
                The return type could be UnnamedConversionNodeTypes.date_idate, but it is useful in more cases to already
                apply the implicit conversion to NodeTypes.date.
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Build.GrammarBuilders.Nodes.NodeUnnamedConversionRules.idate_fromDateTime(Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.fromDateTime)">
            <summary> Build a typed program node correponding to the ~convert_idate_fromDateTime rule.</summary>
            <remarks>
                The return type could be UnnamedConversionNodeTypes.idate_fromDateTime, but it is useful in more cases to already
                apply the implicit conversion to NodeTypes.idate.
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Build.GrammarBuilders.Nodes.NodeUnnamedConversionRules.idate_fromDateTimePart(Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.fromDateTimePart)">
            <summary> Build a typed program node correponding to the ~convert_idate_fromDateTimePart rule.</summary>
            <remarks>
                The return type could be UnnamedConversionNodeTypes.idate_fromDateTimePart, but it is useful in more cases to already
                apply the implicit conversion to NodeTypes.idate.
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Build.GrammarBuilders.Nodes.NodeUnnamedConversionRules.itime_fromTime(Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.fromTime)">
            <summary> Build a typed program node correponding to the ~convert_itime_fromTime rule.</summary>
            <remarks>
                The return type could be UnnamedConversionNodeTypes.itime_fromTime, but it is useful in more cases to already
                apply the implicit conversion to NodeTypes.itime.
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Build.GrammarBuilders.Nodes.NodeUnnamedConversionRules.parseSubject_fromStr(Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.fromStr)">
            <summary> Build a typed program node correponding to the ~convert_parseSubject_fromStr rule.</summary>
            <remarks>
                The return type could be UnnamedConversionNodeTypes.parseSubject_fromStr, but it is useful in more cases to already
                apply the implicit conversion to NodeTypes.parseSubject.
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Build.GrammarBuilders.Nodes.NodeUnnamedConversionRules.parseSubject_letSubstring(Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.letSubstring)">
            <summary> Build a typed program node correponding to the ~convert_parseSubject_letSubstring rule.</summary>
            <remarks>
                The return type could be UnnamedConversionNodeTypes.parseSubject_letSubstring, but it is useful in more cases to already
                apply the implicit conversion to NodeTypes.parseSubject.
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Build.GrammarBuilders.Nodes.NodeUnnamedConversionRules.substring_splitTrim(Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.splitTrim)">
            <summary> Build a typed program node correponding to the ~convert_substring_splitTrim rule.</summary>
            <remarks>
                The return type could be UnnamedConversionNodeTypes.substring_splitTrim, but it is useful in more cases to already
                apply the implicit conversion to NodeTypes.substring.
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Build.GrammarBuilders.Nodes.NodeUnnamedConversionRules.substring_sliceTrim(Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.sliceTrim)">
            <summary> Build a typed program node correponding to the ~convert_substring_sliceTrim rule.</summary>
            <remarks>
                The return type could be UnnamedConversionNodeTypes.substring_sliceTrim, but it is useful in more cases to already
                apply the implicit conversion to NodeTypes.substring.
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Build.GrammarBuilders.Nodes.NodeUnnamedConversionRules.splitTrim_split(Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.split)">
            <summary> Build a typed program node correponding to the ~convert_splitTrim_split rule.</summary>
            <remarks>
                The return type could be UnnamedConversionNodeTypes.splitTrim_split, but it is useful in more cases to already
                apply the implicit conversion to NodeTypes.splitTrim.
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Build.GrammarBuilders.Nodes.NodeUnnamedConversionRules.sliceTrim_slice(Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.slice)">
            <summary> Build a typed program node correponding to the ~convert_sliceTrim_slice rule.</summary>
            <remarks>
                The return type could be UnnamedConversionNodeTypes.sliceTrim_slice, but it is useful in more cases to already
                apply the implicit conversion to NodeTypes.sliceTrim.
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Build.GrammarBuilders.Nodes.NodeUnnamedConversionRules.fromLookupKey_fromStr(Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.fromStr)">
            <summary> Build a typed program node correponding to the ~convert_fromLookupKey_fromStr rule.</summary>
            <remarks>
                The return type could be UnnamedConversionNodeTypes.fromLookupKey_fromStr, but it is useful in more cases to already
                apply the implicit conversion to NodeTypes.fromLookupKey.
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Build.GrammarBuilders.Nodes.NodeUnnamedConversionRules.fromLookupKey_letSubstring(Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.letSubstring)">
            <summary> Build a typed program node correponding to the ~convert_fromLookupKey_letSubstring rule.</summary>
            <remarks>
                The return type could be UnnamedConversionNodeTypes.fromLookupKey_letSubstring, but it is useful in more cases to already
                apply the implicit conversion to NodeTypes.fromLookupKey.
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Build.GrammarBuilders.Nodes.NodeUnnamedConversionRules.fromStrTrim_fromStr(Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.fromStr)">
            <summary> Build a typed program node correponding to the ~convert_fromStrTrim_fromStr rule.</summary>
            <remarks>
                The return type could be UnnamedConversionNodeTypes.fromStrTrim_fromStr, but it is useful in more cases to already
                apply the implicit conversion to NodeTypes.fromStrTrim.
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Transformation.Formula.Build.GrammarBuilders.Nodes.NodeUnnamedConversionRules.fromStrTrim_fromNumberStr(Microsoft.ProgramSynthesis.Transformation.Formula.Build.NodeTypes.fromNumberStr)">
            <summary> Build a typed program node correponding to the ~convert_fromStrTrim_fromNumberStr rule.</summary>
            <remarks>
                The return type could be UnnamedConversionNodeTypes.fromStrTrim_fromNumberStr, but it is useful in more cases to already
                apply the implicit conversion to NodeTypes.fromStrTrim.
            </remarks>
        </member>
    </members>
</doc>
